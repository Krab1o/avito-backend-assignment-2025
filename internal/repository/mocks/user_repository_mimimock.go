// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Krab1o/avito-backend-assignment-2025/internal/repository.UserRepository -o user_repository_mimimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	userModel "github.com/Krab1o/avito-backend-assignment-2025/internal/repository/user/model"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// UserRepositoryMock implements mm_repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCoins          func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error)
	funcAddCoinsOrigin    string
	inspectFuncAddCoins   func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int)
	afterAddCoinsCounter  uint64
	beforeAddCoinsCounter uint64
	AddCoinsMock          mUserRepositoryMockAddCoins

	funcCreateUser          func(ctx context.Context, tx pgx.Tx, creds *userModel.User) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, tx pgx.Tx, creds *userModel.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRepositoryMockCreateUser

	funcGetUserByID          func(ctx context.Context, tx pgx.Tx, id int64) (up1 *userModel.User, err error)
	funcGetUserByIDOrigin    string
	inspectFuncGetUserByID   func(ctx context.Context, tx pgx.Tx, id int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mUserRepositoryMockGetUserByID

	funcGetUserByUsername          func(ctx context.Context, tx pgx.Tx, username string) (up1 *userModel.User, err error)
	funcGetUserByUsernameOrigin    string
	inspectFuncGetUserByUsername   func(ctx context.Context, tx pgx.Tx, username string)
	afterGetUserByUsernameCounter  uint64
	beforeGetUserByUsernameCounter uint64
	GetUserByUsernameMock          mUserRepositoryMockGetUserByUsername

	funcSubtractCoins          func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error)
	funcSubtractCoinsOrigin    string
	inspectFuncSubtractCoins   func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int)
	afterSubtractCoinsCounter  uint64
	beforeSubtractCoinsCounter uint64
	SubtractCoinsMock          mUserRepositoryMockSubtractCoins

	funcWithTransaction          func(ctx context.Context, fn func(tx pgx.Tx) error) (err error)
	funcWithTransactionOrigin    string
	inspectFuncWithTransaction   func(ctx context.Context, fn func(tx pgx.Tx) error)
	afterWithTransactionCounter  uint64
	beforeWithTransactionCounter uint64
	WithTransactionMock          mUserRepositoryMockWithTransaction
}

// NewUserRepositoryMock returns a mock for mm_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCoinsMock = mUserRepositoryMockAddCoins{mock: m}
	m.AddCoinsMock.callArgs = []*UserRepositoryMockAddCoinsParams{}

	m.CreateUserMock = mUserRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRepositoryMockCreateUserParams{}

	m.GetUserByIDMock = mUserRepositoryMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*UserRepositoryMockGetUserByIDParams{}

	m.GetUserByUsernameMock = mUserRepositoryMockGetUserByUsername{mock: m}
	m.GetUserByUsernameMock.callArgs = []*UserRepositoryMockGetUserByUsernameParams{}

	m.SubtractCoinsMock = mUserRepositoryMockSubtractCoins{mock: m}
	m.SubtractCoinsMock.callArgs = []*UserRepositoryMockSubtractCoinsParams{}

	m.WithTransactionMock = mUserRepositoryMockWithTransaction{mock: m}
	m.WithTransactionMock.callArgs = []*UserRepositoryMockWithTransactionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockAddCoins struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockAddCoinsExpectation
	expectations       []*UserRepositoryMockAddCoinsExpectation

	callArgs []*UserRepositoryMockAddCoinsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockAddCoinsExpectation specifies expectation struct of the UserRepository.AddCoins
type UserRepositoryMockAddCoinsExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockAddCoinsParams
	paramPtrs          *UserRepositoryMockAddCoinsParamPtrs
	expectationOrigins UserRepositoryMockAddCoinsExpectationOrigins
	results            *UserRepositoryMockAddCoinsResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockAddCoinsParams contains parameters of the UserRepository.AddCoins
type UserRepositoryMockAddCoinsParams struct {
	ctx   context.Context
	tx    pgx.Tx
	user  *userModel.User
	value int
}

// UserRepositoryMockAddCoinsParamPtrs contains pointers to parameters of the UserRepository.AddCoins
type UserRepositoryMockAddCoinsParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	user  **userModel.User
	value *int
}

// UserRepositoryMockAddCoinsResults contains results of the UserRepository.AddCoins
type UserRepositoryMockAddCoinsResults struct {
	err error
}

// UserRepositoryMockAddCoinsOrigins contains origins of expectations of the UserRepository.AddCoins
type UserRepositoryMockAddCoinsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originUser  string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCoins *mUserRepositoryMockAddCoins) Optional() *mUserRepositoryMockAddCoins {
	mmAddCoins.optional = true
	return mmAddCoins
}

// Expect sets up expected params for UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) Expect(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{}
	}

	if mmAddCoins.defaultExpectation.paramPtrs != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by ExpectParams functions")
	}

	mmAddCoins.defaultExpectation.params = &UserRepositoryMockAddCoinsParams{ctx, tx, user, value}
	mmAddCoins.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCoins.expectations {
		if minimock.Equal(e.params, mmAddCoins.defaultExpectation.params) {
			mmAddCoins.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCoins.defaultExpectation.params)
		}
	}

	return mmAddCoins
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{}
	}

	if mmAddCoins.defaultExpectation.params != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Expect")
	}

	if mmAddCoins.defaultExpectation.paramPtrs == nil {
		mmAddCoins.defaultExpectation.paramPtrs = &UserRepositoryMockAddCoinsParamPtrs{}
	}
	mmAddCoins.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddCoins.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddCoins
}

// ExpectTxParam2 sets up expected param tx for UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) ExpectTxParam2(tx pgx.Tx) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{}
	}

	if mmAddCoins.defaultExpectation.params != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Expect")
	}

	if mmAddCoins.defaultExpectation.paramPtrs == nil {
		mmAddCoins.defaultExpectation.paramPtrs = &UserRepositoryMockAddCoinsParamPtrs{}
	}
	mmAddCoins.defaultExpectation.paramPtrs.tx = &tx
	mmAddCoins.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmAddCoins
}

// ExpectUserParam3 sets up expected param user for UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) ExpectUserParam3(user *userModel.User) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{}
	}

	if mmAddCoins.defaultExpectation.params != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Expect")
	}

	if mmAddCoins.defaultExpectation.paramPtrs == nil {
		mmAddCoins.defaultExpectation.paramPtrs = &UserRepositoryMockAddCoinsParamPtrs{}
	}
	mmAddCoins.defaultExpectation.paramPtrs.user = &user
	mmAddCoins.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmAddCoins
}

// ExpectValueParam4 sets up expected param value for UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) ExpectValueParam4(value int) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{}
	}

	if mmAddCoins.defaultExpectation.params != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Expect")
	}

	if mmAddCoins.defaultExpectation.paramPtrs == nil {
		mmAddCoins.defaultExpectation.paramPtrs = &UserRepositoryMockAddCoinsParamPtrs{}
	}
	mmAddCoins.defaultExpectation.paramPtrs.value = &value
	mmAddCoins.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAddCoins
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) Inspect(f func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int)) *mUserRepositoryMockAddCoins {
	if mmAddCoins.mock.inspectFuncAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.AddCoins")
	}

	mmAddCoins.mock.inspectFuncAddCoins = f

	return mmAddCoins
}

// Return sets up results that will be returned by UserRepository.AddCoins
func (mmAddCoins *mUserRepositoryMockAddCoins) Return(err error) *UserRepositoryMock {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	if mmAddCoins.defaultExpectation == nil {
		mmAddCoins.defaultExpectation = &UserRepositoryMockAddCoinsExpectation{mock: mmAddCoins.mock}
	}
	mmAddCoins.defaultExpectation.results = &UserRepositoryMockAddCoinsResults{err}
	mmAddCoins.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCoins.mock
}

// Set uses given function f to mock the UserRepository.AddCoins method
func (mmAddCoins *mUserRepositoryMockAddCoins) Set(f func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error)) *UserRepositoryMock {
	if mmAddCoins.defaultExpectation != nil {
		mmAddCoins.mock.t.Fatalf("Default expectation is already set for the UserRepository.AddCoins method")
	}

	if len(mmAddCoins.expectations) > 0 {
		mmAddCoins.mock.t.Fatalf("Some expectations are already set for the UserRepository.AddCoins method")
	}

	mmAddCoins.mock.funcAddCoins = f
	mmAddCoins.mock.funcAddCoinsOrigin = minimock.CallerInfo(1)
	return mmAddCoins.mock
}

// When sets expectation for the UserRepository.AddCoins which will trigger the result defined by the following
// Then helper
func (mmAddCoins *mUserRepositoryMockAddCoins) When(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) *UserRepositoryMockAddCoinsExpectation {
	if mmAddCoins.mock.funcAddCoins != nil {
		mmAddCoins.mock.t.Fatalf("UserRepositoryMock.AddCoins mock is already set by Set")
	}

	expectation := &UserRepositoryMockAddCoinsExpectation{
		mock:               mmAddCoins.mock,
		params:             &UserRepositoryMockAddCoinsParams{ctx, tx, user, value},
		expectationOrigins: UserRepositoryMockAddCoinsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCoins.expectations = append(mmAddCoins.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.AddCoins return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockAddCoinsExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockAddCoinsResults{err}
	return e.mock
}

// Times sets number of times UserRepository.AddCoins should be invoked
func (mmAddCoins *mUserRepositoryMockAddCoins) Times(n uint64) *mUserRepositoryMockAddCoins {
	if n == 0 {
		mmAddCoins.mock.t.Fatalf("Times of UserRepositoryMock.AddCoins mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCoins.expectedInvocations, n)
	mmAddCoins.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCoins
}

func (mmAddCoins *mUserRepositoryMockAddCoins) invocationsDone() bool {
	if len(mmAddCoins.expectations) == 0 && mmAddCoins.defaultExpectation == nil && mmAddCoins.mock.funcAddCoins == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCoins.mock.afterAddCoinsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCoins.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCoins implements mm_repository.UserRepository
func (mmAddCoins *UserRepositoryMock) AddCoins(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error) {
	mm_atomic.AddUint64(&mmAddCoins.beforeAddCoinsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCoins.afterAddCoinsCounter, 1)

	mmAddCoins.t.Helper()

	if mmAddCoins.inspectFuncAddCoins != nil {
		mmAddCoins.inspectFuncAddCoins(ctx, tx, user, value)
	}

	mm_params := UserRepositoryMockAddCoinsParams{ctx, tx, user, value}

	// Record call args
	mmAddCoins.AddCoinsMock.mutex.Lock()
	mmAddCoins.AddCoinsMock.callArgs = append(mmAddCoins.AddCoinsMock.callArgs, &mm_params)
	mmAddCoins.AddCoinsMock.mutex.Unlock()

	for _, e := range mmAddCoins.AddCoinsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCoins.AddCoinsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCoins.AddCoinsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCoins.AddCoinsMock.defaultExpectation.params
		mm_want_ptrs := mmAddCoins.AddCoinsMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockAddCoinsParams{ctx, tx, user, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddCoins.t.Errorf("UserRepositoryMock.AddCoins got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCoins.AddCoinsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmAddCoins.t.Errorf("UserRepositoryMock.AddCoins got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCoins.AddCoinsMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmAddCoins.t.Errorf("UserRepositoryMock.AddCoins got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCoins.AddCoinsMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAddCoins.t.Errorf("UserRepositoryMock.AddCoins got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCoins.AddCoinsMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCoins.t.Errorf("UserRepositoryMock.AddCoins got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCoins.AddCoinsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCoins.AddCoinsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCoins.t.Fatal("No results are set for the UserRepositoryMock.AddCoins")
		}
		return (*mm_results).err
	}
	if mmAddCoins.funcAddCoins != nil {
		return mmAddCoins.funcAddCoins(ctx, tx, user, value)
	}
	mmAddCoins.t.Fatalf("Unexpected call to UserRepositoryMock.AddCoins. %v %v %v %v", ctx, tx, user, value)
	return
}

// AddCoinsAfterCounter returns a count of finished UserRepositoryMock.AddCoins invocations
func (mmAddCoins *UserRepositoryMock) AddCoinsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCoins.afterAddCoinsCounter)
}

// AddCoinsBeforeCounter returns a count of UserRepositoryMock.AddCoins invocations
func (mmAddCoins *UserRepositoryMock) AddCoinsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCoins.beforeAddCoinsCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.AddCoins.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCoins *mUserRepositoryMockAddCoins) Calls() []*UserRepositoryMockAddCoinsParams {
	mmAddCoins.mutex.RLock()

	argCopy := make([]*UserRepositoryMockAddCoinsParams, len(mmAddCoins.callArgs))
	copy(argCopy, mmAddCoins.callArgs)

	mmAddCoins.mutex.RUnlock()

	return argCopy
}

// MinimockAddCoinsDone returns true if the count of the AddCoins invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockAddCoinsDone() bool {
	if m.AddCoinsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCoinsMock.invocationsDone()
}

// MinimockAddCoinsInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockAddCoinsInspect() {
	for _, e := range m.AddCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.AddCoins at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCoinsCounter := mm_atomic.LoadUint64(&m.afterAddCoinsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCoinsMock.defaultExpectation != nil && afterAddCoinsCounter < 1 {
		if m.AddCoinsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.AddCoins at\n%s", m.AddCoinsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.AddCoins at\n%s with params: %#v", m.AddCoinsMock.defaultExpectation.expectationOrigins.origin, *m.AddCoinsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCoins != nil && afterAddCoinsCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.AddCoins at\n%s", m.funcAddCoinsOrigin)
	}

	if !m.AddCoinsMock.invocationsDone() && afterAddCoinsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.AddCoins at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCoinsMock.expectedInvocations), m.AddCoinsMock.expectedInvocationsOrigin, afterAddCoinsCounter)
	}
}

type mUserRepositoryMockCreateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateUserExpectation
	expectations       []*UserRepositoryMockCreateUserExpectation

	callArgs []*UserRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockCreateUserExpectation specifies expectation struct of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockCreateUserParams
	paramPtrs          *UserRepositoryMockCreateUserParamPtrs
	expectationOrigins UserRepositoryMockCreateUserExpectationOrigins
	results            *UserRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockCreateUserParams contains parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParams struct {
	ctx   context.Context
	tx    pgx.Tx
	creds *userModel.User
}

// UserRepositoryMockCreateUserParamPtrs contains pointers to parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	creds **userModel.User
}

// UserRepositoryMockCreateUserResults contains results of the UserRepository.CreateUser
type UserRepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// UserRepositoryMockCreateUserOrigins contains origins of expectations of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originCreds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepositoryMockCreateUser) Optional() *mUserRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Expect(ctx context.Context, tx pgx.Tx, creds *userModel.User) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRepositoryMockCreateUserParams{ctx, tx, creds}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectTxParam2 sets up expected param tx for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectTxParam2(tx pgx.Tx) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.tx = &tx
	mmCreateUser.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectCredsParam3 sets up expected param creds for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectCredsParam3(creds *userModel.User) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.creds = &creds
	mmCreateUser.defaultExpectation.expectationOrigins.originCreds = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Inspect(f func(ctx context.Context, tx pgx.Tx, creds *userModel.User)) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRepository.CreateUser method
func (mmCreateUser *mUserRepositoryMockCreateUser) Set(f func(ctx context.Context, tx pgx.Tx, creds *userModel.User) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepositoryMockCreateUser) When(ctx context.Context, tx pgx.Tx, creds *userModel.User) *UserRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserRepositoryMockCreateUserParams{ctx, tx, creds},
		expectationOrigins: UserRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateUserExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.CreateUser should be invoked
func (mmCreateUser *mUserRepositoryMockCreateUser) Times(n uint64) *mUserRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.UserRepository
func (mmCreateUser *UserRepositoryMock) CreateUser(ctx context.Context, tx pgx.Tx, creds *userModel.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, tx, creds)
	}

	mm_params := UserRepositoryMockCreateUserParams{ctx, tx, creds}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateUserParams{ctx, tx, creds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.creds != nil && !minimock.Equal(*mm_want_ptrs.creds, mm_got.creds) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter creds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCreds, *mm_want_ptrs.creds, mm_got.creds, minimock.Diff(*mm_want_ptrs.creds, mm_got.creds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, tx, creds)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRepositoryMock.CreateUser. %v %v %v", ctx, tx, creds)
	return
}

// CreateUserAfterCounter returns a count of finished UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepositoryMockCreateUser) Calls() []*UserRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserRepositoryMockGetUserByID struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserByIDExpectation
	expectations       []*UserRepositoryMockGetUserByIDExpectation

	callArgs []*UserRepositoryMockGetUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetUserByIDExpectation specifies expectation struct of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetUserByIDParams
	paramPtrs          *UserRepositoryMockGetUserByIDParamPtrs
	expectationOrigins UserRepositoryMockGetUserByIDExpectationOrigins
	results            *UserRepositoryMockGetUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetUserByIDParams contains parameters of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDParams struct {
	ctx context.Context
	tx  pgx.Tx
	id  int64
}

// UserRepositoryMockGetUserByIDParamPtrs contains pointers to parameters of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDParamPtrs struct {
	ctx *context.Context
	tx  *pgx.Tx
	id  *int64
}

// UserRepositoryMockGetUserByIDResults contains results of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDResults struct {
	up1 *userModel.User
	err error
}

// UserRepositoryMockGetUserByIDOrigins contains origins of expectations of the UserRepository.GetUserByID
type UserRepositoryMockGetUserByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originTx  string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Optional() *mUserRepositoryMockGetUserByID {
	mmGetUserByID.optional = true
	return mmGetUserByID
}

// Expect sets up expected params for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Expect(ctx context.Context, tx pgx.Tx, id int64) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.paramPtrs != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by ExpectParams functions")
	}

	mmGetUserByID.defaultExpectation.params = &UserRepositoryMockGetUserByIDParams{ctx, tx, id}
	mmGetUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByID
}

// ExpectTxParam2 sets up expected param tx for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) ExpectTxParam2(tx pgx.Tx) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.tx = &tx
	mmGetUserByID.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmGetUserByID
}

// ExpectIdParam3 sets up expected param id for UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) ExpectIdParam3(id int64) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{}
	}

	if mmGetUserByID.defaultExpectation.params != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Expect")
	}

	if mmGetUserByID.defaultExpectation.paramPtrs == nil {
		mmGetUserByID.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByIDParamPtrs{}
	}
	mmGetUserByID.defaultExpectation.paramPtrs.id = &id
	mmGetUserByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Inspect(f func(ctx context.Context, tx pgx.Tx, id int64)) *mUserRepositoryMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by UserRepository.GetUserByID
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Return(up1 *userModel.User, err error) *UserRepositoryMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserRepositoryMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &UserRepositoryMockGetUserByIDResults{up1, err}
	mmGetUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// Set uses given function f to mock the UserRepository.GetUserByID method
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Set(f func(ctx context.Context, tx pgx.Tx, id int64) (up1 *userModel.User, err error)) *UserRepositoryMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	mmGetUserByID.mock.funcGetUserByIDOrigin = minimock.CallerInfo(1)
	return mmGetUserByID.mock
}

// When sets expectation for the UserRepository.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mUserRepositoryMockGetUserByID) When(ctx context.Context, tx pgx.Tx, id int64) *UserRepositoryMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserRepositoryMock.GetUserByID mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserByIDExpectation{
		mock:               mmGetUserByID.mock,
		params:             &UserRepositoryMockGetUserByIDParams{ctx, tx, id},
		expectationOrigins: UserRepositoryMockGetUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUserByID return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserByIDExpectation) Then(up1 *userModel.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUserByID should be invoked
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Times(n uint64) *mUserRepositoryMockGetUserByID {
	if n == 0 {
		mmGetUserByID.mock.t.Fatalf("Times of UserRepositoryMock.GetUserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByID.expectedInvocations, n)
	mmGetUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByID
}

func (mmGetUserByID *mUserRepositoryMockGetUserByID) invocationsDone() bool {
	if len(mmGetUserByID.expectations) == 0 && mmGetUserByID.defaultExpectation == nil && mmGetUserByID.mock.funcGetUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByID.mock.afterGetUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByID implements mm_repository.UserRepository
func (mmGetUserByID *UserRepositoryMock) GetUserByID(ctx context.Context, tx pgx.Tx, id int64) (up1 *userModel.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	mmGetUserByID.t.Helper()

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, tx, id)
	}

	mm_params := UserRepositoryMockGetUserByIDParams{ctx, tx, id}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, &mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByID.GetUserByIDMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserByIDParams{ctx, tx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("UserRepositoryMock.GetUserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByID.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the UserRepositoryMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, tx, id)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to UserRepositoryMock.GetUserByID. %v %v %v", ctx, tx, id)
	return
}

// GetUserByIDAfterCounter returns a count of finished UserRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UserRepositoryMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of UserRepositoryMock.GetUserByID invocations
func (mmGetUserByID *UserRepositoryMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mUserRepositoryMockGetUserByID) Calls() []*UserRepositoryMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserByIDDone() bool {
	if m.GetUserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByIDMock.invocationsDone()
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByIDCounter := mm_atomic.LoadUint64(&m.afterGetUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && afterGetUserByIDCounter < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s", m.GetUserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s with params: %#v", m.GetUserByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && afterGetUserByIDCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetUserByID at\n%s", m.funcGetUserByIDOrigin)
	}

	if !m.GetUserByIDMock.invocationsDone() && afterGetUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByIDMock.expectedInvocations), m.GetUserByIDMock.expectedInvocationsOrigin, afterGetUserByIDCounter)
	}
}

type mUserRepositoryMockGetUserByUsername struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserByUsernameExpectation
	expectations       []*UserRepositoryMockGetUserByUsernameExpectation

	callArgs []*UserRepositoryMockGetUserByUsernameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockGetUserByUsernameExpectation specifies expectation struct of the UserRepository.GetUserByUsername
type UserRepositoryMockGetUserByUsernameExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockGetUserByUsernameParams
	paramPtrs          *UserRepositoryMockGetUserByUsernameParamPtrs
	expectationOrigins UserRepositoryMockGetUserByUsernameExpectationOrigins
	results            *UserRepositoryMockGetUserByUsernameResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockGetUserByUsernameParams contains parameters of the UserRepository.GetUserByUsername
type UserRepositoryMockGetUserByUsernameParams struct {
	ctx      context.Context
	tx       pgx.Tx
	username string
}

// UserRepositoryMockGetUserByUsernameParamPtrs contains pointers to parameters of the UserRepository.GetUserByUsername
type UserRepositoryMockGetUserByUsernameParamPtrs struct {
	ctx      *context.Context
	tx       *pgx.Tx
	username *string
}

// UserRepositoryMockGetUserByUsernameResults contains results of the UserRepository.GetUserByUsername
type UserRepositoryMockGetUserByUsernameResults struct {
	up1 *userModel.User
	err error
}

// UserRepositoryMockGetUserByUsernameOrigins contains origins of expectations of the UserRepository.GetUserByUsername
type UserRepositoryMockGetUserByUsernameExpectationOrigins struct {
	origin         string
	originCtx      string
	originTx       string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Optional() *mUserRepositoryMockGetUserByUsername {
	mmGetUserByUsername.optional = true
	return mmGetUserByUsername
}

// Expect sets up expected params for UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Expect(ctx context.Context, tx pgx.Tx, username string) *mUserRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &UserRepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by ExpectParams functions")
	}

	mmGetUserByUsername.defaultExpectation.params = &UserRepositoryMockGetUserByUsernameParams{ctx, tx, username}
	mmGetUserByUsername.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByUsername.expectations {
		if minimock.Equal(e.params, mmGetUserByUsername.defaultExpectation.params) {
			mmGetUserByUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByUsername.defaultExpectation.params)
		}
	}

	return mmGetUserByUsername
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &UserRepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// ExpectTxParam2 sets up expected param tx for UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) ExpectTxParam2(tx pgx.Tx) *mUserRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &UserRepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.tx = &tx
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// ExpectUsernameParam3 sets up expected param username for UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) ExpectUsernameParam3(username string) *mUserRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &UserRepositoryMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.username = &username
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Inspect(f func(ctx context.Context, tx pgx.Tx, username string)) *mUserRepositoryMockGetUserByUsername {
	if mmGetUserByUsername.mock.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUserByUsername")
	}

	mmGetUserByUsername.mock.inspectFuncGetUserByUsername = f

	return mmGetUserByUsername
}

// Return sets up results that will be returned by UserRepository.GetUserByUsername
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Return(up1 *userModel.User, err error) *UserRepositoryMock {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &UserRepositoryMockGetUserByUsernameExpectation{mock: mmGetUserByUsername.mock}
	}
	mmGetUserByUsername.defaultExpectation.results = &UserRepositoryMockGetUserByUsernameResults{up1, err}
	mmGetUserByUsername.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// Set uses given function f to mock the UserRepository.GetUserByUsername method
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Set(f func(ctx context.Context, tx pgx.Tx, username string) (up1 *userModel.User, err error)) *UserRepositoryMock {
	if mmGetUserByUsername.defaultExpectation != nil {
		mmGetUserByUsername.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUserByUsername method")
	}

	if len(mmGetUserByUsername.expectations) > 0 {
		mmGetUserByUsername.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUserByUsername method")
	}

	mmGetUserByUsername.mock.funcGetUserByUsername = f
	mmGetUserByUsername.mock.funcGetUserByUsernameOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// When sets expectation for the UserRepository.GetUserByUsername which will trigger the result defined by the following
// Then helper
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) When(ctx context.Context, tx pgx.Tx, username string) *UserRepositoryMockGetUserByUsernameExpectation {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("UserRepositoryMock.GetUserByUsername mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserByUsernameExpectation{
		mock:               mmGetUserByUsername.mock,
		params:             &UserRepositoryMockGetUserByUsernameParams{ctx, tx, username},
		expectationOrigins: UserRepositoryMockGetUserByUsernameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByUsername.expectations = append(mmGetUserByUsername.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUserByUsername return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserByUsernameExpectation) Then(up1 *userModel.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserByUsernameResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUserByUsername should be invoked
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Times(n uint64) *mUserRepositoryMockGetUserByUsername {
	if n == 0 {
		mmGetUserByUsername.mock.t.Fatalf("Times of UserRepositoryMock.GetUserByUsername mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByUsername.expectedInvocations, n)
	mmGetUserByUsername.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername
}

func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) invocationsDone() bool {
	if len(mmGetUserByUsername.expectations) == 0 && mmGetUserByUsername.defaultExpectation == nil && mmGetUserByUsername.mock.funcGetUserByUsername == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.mock.afterGetUserByUsernameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByUsername implements mm_repository.UserRepository
func (mmGetUserByUsername *UserRepositoryMock) GetUserByUsername(ctx context.Context, tx pgx.Tx, username string) (up1 *userModel.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter, 1)

	mmGetUserByUsername.t.Helper()

	if mmGetUserByUsername.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.inspectFuncGetUserByUsername(ctx, tx, username)
	}

	mm_params := UserRepositoryMockGetUserByUsernameParams{ctx, tx, username}

	// Record call args
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Lock()
	mmGetUserByUsername.GetUserByUsernameMock.callArgs = append(mmGetUserByUsername.GetUserByUsernameMock.callArgs, &mm_params)
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Unlock()

	for _, e := range mmGetUserByUsername.GetUserByUsernameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserByUsernameParams{ctx, tx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByUsername.t.Errorf("UserRepositoryMock.GetUserByUsername got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmGetUserByUsername.t.Errorf("UserRepositoryMock.GetUserByUsername got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserByUsername.t.Errorf("UserRepositoryMock.GetUserByUsername got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByUsername.t.Errorf("UserRepositoryMock.GetUserByUsername got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByUsername.t.Fatal("No results are set for the UserRepositoryMock.GetUserByUsername")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByUsername.funcGetUserByUsername != nil {
		return mmGetUserByUsername.funcGetUserByUsername(ctx, tx, username)
	}
	mmGetUserByUsername.t.Fatalf("Unexpected call to UserRepositoryMock.GetUserByUsername. %v %v %v", ctx, tx, username)
	return
}

// GetUserByUsernameAfterCounter returns a count of finished UserRepositoryMock.GetUserByUsername invocations
func (mmGetUserByUsername *UserRepositoryMock) GetUserByUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter)
}

// GetUserByUsernameBeforeCounter returns a count of UserRepositoryMock.GetUserByUsername invocations
func (mmGetUserByUsername *UserRepositoryMock) GetUserByUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUserByUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByUsername *mUserRepositoryMockGetUserByUsername) Calls() []*UserRepositoryMockGetUserByUsernameParams {
	mmGetUserByUsername.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserByUsernameParams, len(mmGetUserByUsername.callArgs))
	copy(argCopy, mmGetUserByUsername.callArgs)

	mmGetUserByUsername.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByUsernameDone returns true if the count of the GetUserByUsername invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserByUsernameDone() bool {
	if m.GetUserByUsernameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByUsernameMock.invocationsDone()
}

// MinimockGetUserByUsernameInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserByUsernameInspect() {
	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByUsername at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByUsernameCounter := mm_atomic.LoadUint64(&m.afterGetUserByUsernameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByUsernameMock.defaultExpectation != nil && afterGetUserByUsernameCounter < 1 {
		if m.GetUserByUsernameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByUsername at\n%s", m.GetUserByUsernameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByUsername at\n%s with params: %#v", m.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByUsername != nil && afterGetUserByUsernameCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.GetUserByUsername at\n%s", m.funcGetUserByUsernameOrigin)
	}

	if !m.GetUserByUsernameMock.invocationsDone() && afterGetUserByUsernameCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUserByUsername at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByUsernameMock.expectedInvocations), m.GetUserByUsernameMock.expectedInvocationsOrigin, afterGetUserByUsernameCounter)
	}
}

type mUserRepositoryMockSubtractCoins struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockSubtractCoinsExpectation
	expectations       []*UserRepositoryMockSubtractCoinsExpectation

	callArgs []*UserRepositoryMockSubtractCoinsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockSubtractCoinsExpectation specifies expectation struct of the UserRepository.SubtractCoins
type UserRepositoryMockSubtractCoinsExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockSubtractCoinsParams
	paramPtrs          *UserRepositoryMockSubtractCoinsParamPtrs
	expectationOrigins UserRepositoryMockSubtractCoinsExpectationOrigins
	results            *UserRepositoryMockSubtractCoinsResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockSubtractCoinsParams contains parameters of the UserRepository.SubtractCoins
type UserRepositoryMockSubtractCoinsParams struct {
	ctx   context.Context
	tx    pgx.Tx
	user  *userModel.User
	value int
}

// UserRepositoryMockSubtractCoinsParamPtrs contains pointers to parameters of the UserRepository.SubtractCoins
type UserRepositoryMockSubtractCoinsParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	user  **userModel.User
	value *int
}

// UserRepositoryMockSubtractCoinsResults contains results of the UserRepository.SubtractCoins
type UserRepositoryMockSubtractCoinsResults struct {
	err error
}

// UserRepositoryMockSubtractCoinsOrigins contains origins of expectations of the UserRepository.SubtractCoins
type UserRepositoryMockSubtractCoinsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originUser  string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Optional() *mUserRepositoryMockSubtractCoins {
	mmSubtractCoins.optional = true
	return mmSubtractCoins
}

// Expect sets up expected params for UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Expect(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{}
	}

	if mmSubtractCoins.defaultExpectation.paramPtrs != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by ExpectParams functions")
	}

	mmSubtractCoins.defaultExpectation.params = &UserRepositoryMockSubtractCoinsParams{ctx, tx, user, value}
	mmSubtractCoins.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSubtractCoins.expectations {
		if minimock.Equal(e.params, mmSubtractCoins.defaultExpectation.params) {
			mmSubtractCoins.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubtractCoins.defaultExpectation.params)
		}
	}

	return mmSubtractCoins
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{}
	}

	if mmSubtractCoins.defaultExpectation.params != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Expect")
	}

	if mmSubtractCoins.defaultExpectation.paramPtrs == nil {
		mmSubtractCoins.defaultExpectation.paramPtrs = &UserRepositoryMockSubtractCoinsParamPtrs{}
	}
	mmSubtractCoins.defaultExpectation.paramPtrs.ctx = &ctx
	mmSubtractCoins.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSubtractCoins
}

// ExpectTxParam2 sets up expected param tx for UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) ExpectTxParam2(tx pgx.Tx) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{}
	}

	if mmSubtractCoins.defaultExpectation.params != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Expect")
	}

	if mmSubtractCoins.defaultExpectation.paramPtrs == nil {
		mmSubtractCoins.defaultExpectation.paramPtrs = &UserRepositoryMockSubtractCoinsParamPtrs{}
	}
	mmSubtractCoins.defaultExpectation.paramPtrs.tx = &tx
	mmSubtractCoins.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmSubtractCoins
}

// ExpectUserParam3 sets up expected param user for UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) ExpectUserParam3(user *userModel.User) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{}
	}

	if mmSubtractCoins.defaultExpectation.params != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Expect")
	}

	if mmSubtractCoins.defaultExpectation.paramPtrs == nil {
		mmSubtractCoins.defaultExpectation.paramPtrs = &UserRepositoryMockSubtractCoinsParamPtrs{}
	}
	mmSubtractCoins.defaultExpectation.paramPtrs.user = &user
	mmSubtractCoins.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSubtractCoins
}

// ExpectValueParam4 sets up expected param value for UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) ExpectValueParam4(value int) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{}
	}

	if mmSubtractCoins.defaultExpectation.params != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Expect")
	}

	if mmSubtractCoins.defaultExpectation.paramPtrs == nil {
		mmSubtractCoins.defaultExpectation.paramPtrs = &UserRepositoryMockSubtractCoinsParamPtrs{}
	}
	mmSubtractCoins.defaultExpectation.paramPtrs.value = &value
	mmSubtractCoins.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSubtractCoins
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Inspect(f func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int)) *mUserRepositoryMockSubtractCoins {
	if mmSubtractCoins.mock.inspectFuncSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.SubtractCoins")
	}

	mmSubtractCoins.mock.inspectFuncSubtractCoins = f

	return mmSubtractCoins
}

// Return sets up results that will be returned by UserRepository.SubtractCoins
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Return(err error) *UserRepositoryMock {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	if mmSubtractCoins.defaultExpectation == nil {
		mmSubtractCoins.defaultExpectation = &UserRepositoryMockSubtractCoinsExpectation{mock: mmSubtractCoins.mock}
	}
	mmSubtractCoins.defaultExpectation.results = &UserRepositoryMockSubtractCoinsResults{err}
	mmSubtractCoins.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSubtractCoins.mock
}

// Set uses given function f to mock the UserRepository.SubtractCoins method
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Set(f func(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error)) *UserRepositoryMock {
	if mmSubtractCoins.defaultExpectation != nil {
		mmSubtractCoins.mock.t.Fatalf("Default expectation is already set for the UserRepository.SubtractCoins method")
	}

	if len(mmSubtractCoins.expectations) > 0 {
		mmSubtractCoins.mock.t.Fatalf("Some expectations are already set for the UserRepository.SubtractCoins method")
	}

	mmSubtractCoins.mock.funcSubtractCoins = f
	mmSubtractCoins.mock.funcSubtractCoinsOrigin = minimock.CallerInfo(1)
	return mmSubtractCoins.mock
}

// When sets expectation for the UserRepository.SubtractCoins which will trigger the result defined by the following
// Then helper
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) When(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) *UserRepositoryMockSubtractCoinsExpectation {
	if mmSubtractCoins.mock.funcSubtractCoins != nil {
		mmSubtractCoins.mock.t.Fatalf("UserRepositoryMock.SubtractCoins mock is already set by Set")
	}

	expectation := &UserRepositoryMockSubtractCoinsExpectation{
		mock:               mmSubtractCoins.mock,
		params:             &UserRepositoryMockSubtractCoinsParams{ctx, tx, user, value},
		expectationOrigins: UserRepositoryMockSubtractCoinsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSubtractCoins.expectations = append(mmSubtractCoins.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.SubtractCoins return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockSubtractCoinsExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockSubtractCoinsResults{err}
	return e.mock
}

// Times sets number of times UserRepository.SubtractCoins should be invoked
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Times(n uint64) *mUserRepositoryMockSubtractCoins {
	if n == 0 {
		mmSubtractCoins.mock.t.Fatalf("Times of UserRepositoryMock.SubtractCoins mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSubtractCoins.expectedInvocations, n)
	mmSubtractCoins.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSubtractCoins
}

func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) invocationsDone() bool {
	if len(mmSubtractCoins.expectations) == 0 && mmSubtractCoins.defaultExpectation == nil && mmSubtractCoins.mock.funcSubtractCoins == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSubtractCoins.mock.afterSubtractCoinsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSubtractCoins.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SubtractCoins implements mm_repository.UserRepository
func (mmSubtractCoins *UserRepositoryMock) SubtractCoins(ctx context.Context, tx pgx.Tx, user *userModel.User, value int) (err error) {
	mm_atomic.AddUint64(&mmSubtractCoins.beforeSubtractCoinsCounter, 1)
	defer mm_atomic.AddUint64(&mmSubtractCoins.afterSubtractCoinsCounter, 1)

	mmSubtractCoins.t.Helper()

	if mmSubtractCoins.inspectFuncSubtractCoins != nil {
		mmSubtractCoins.inspectFuncSubtractCoins(ctx, tx, user, value)
	}

	mm_params := UserRepositoryMockSubtractCoinsParams{ctx, tx, user, value}

	// Record call args
	mmSubtractCoins.SubtractCoinsMock.mutex.Lock()
	mmSubtractCoins.SubtractCoinsMock.callArgs = append(mmSubtractCoins.SubtractCoinsMock.callArgs, &mm_params)
	mmSubtractCoins.SubtractCoinsMock.mutex.Unlock()

	for _, e := range mmSubtractCoins.SubtractCoinsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubtractCoins.SubtractCoinsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubtractCoins.SubtractCoinsMock.defaultExpectation.Counter, 1)
		mm_want := mmSubtractCoins.SubtractCoinsMock.defaultExpectation.params
		mm_want_ptrs := mmSubtractCoins.SubtractCoinsMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockSubtractCoinsParams{ctx, tx, user, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSubtractCoins.t.Errorf("UserRepositoryMock.SubtractCoins got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubtractCoins.SubtractCoinsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmSubtractCoins.t.Errorf("UserRepositoryMock.SubtractCoins got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubtractCoins.SubtractCoinsMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSubtractCoins.t.Errorf("UserRepositoryMock.SubtractCoins got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubtractCoins.SubtractCoinsMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSubtractCoins.t.Errorf("UserRepositoryMock.SubtractCoins got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubtractCoins.SubtractCoinsMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubtractCoins.t.Errorf("UserRepositoryMock.SubtractCoins got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSubtractCoins.SubtractCoinsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubtractCoins.SubtractCoinsMock.defaultExpectation.results
		if mm_results == nil {
			mmSubtractCoins.t.Fatal("No results are set for the UserRepositoryMock.SubtractCoins")
		}
		return (*mm_results).err
	}
	if mmSubtractCoins.funcSubtractCoins != nil {
		return mmSubtractCoins.funcSubtractCoins(ctx, tx, user, value)
	}
	mmSubtractCoins.t.Fatalf("Unexpected call to UserRepositoryMock.SubtractCoins. %v %v %v %v", ctx, tx, user, value)
	return
}

// SubtractCoinsAfterCounter returns a count of finished UserRepositoryMock.SubtractCoins invocations
func (mmSubtractCoins *UserRepositoryMock) SubtractCoinsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubtractCoins.afterSubtractCoinsCounter)
}

// SubtractCoinsBeforeCounter returns a count of UserRepositoryMock.SubtractCoins invocations
func (mmSubtractCoins *UserRepositoryMock) SubtractCoinsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubtractCoins.beforeSubtractCoinsCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.SubtractCoins.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubtractCoins *mUserRepositoryMockSubtractCoins) Calls() []*UserRepositoryMockSubtractCoinsParams {
	mmSubtractCoins.mutex.RLock()

	argCopy := make([]*UserRepositoryMockSubtractCoinsParams, len(mmSubtractCoins.callArgs))
	copy(argCopy, mmSubtractCoins.callArgs)

	mmSubtractCoins.mutex.RUnlock()

	return argCopy
}

// MinimockSubtractCoinsDone returns true if the count of the SubtractCoins invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockSubtractCoinsDone() bool {
	if m.SubtractCoinsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SubtractCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SubtractCoinsMock.invocationsDone()
}

// MinimockSubtractCoinsInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockSubtractCoinsInspect() {
	for _, e := range m.SubtractCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.SubtractCoins at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSubtractCoinsCounter := mm_atomic.LoadUint64(&m.afterSubtractCoinsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SubtractCoinsMock.defaultExpectation != nil && afterSubtractCoinsCounter < 1 {
		if m.SubtractCoinsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.SubtractCoins at\n%s", m.SubtractCoinsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.SubtractCoins at\n%s with params: %#v", m.SubtractCoinsMock.defaultExpectation.expectationOrigins.origin, *m.SubtractCoinsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubtractCoins != nil && afterSubtractCoinsCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.SubtractCoins at\n%s", m.funcSubtractCoinsOrigin)
	}

	if !m.SubtractCoinsMock.invocationsDone() && afterSubtractCoinsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.SubtractCoins at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SubtractCoinsMock.expectedInvocations), m.SubtractCoinsMock.expectedInvocationsOrigin, afterSubtractCoinsCounter)
	}
}

type mUserRepositoryMockWithTransaction struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockWithTransactionExpectation
	expectations       []*UserRepositoryMockWithTransactionExpectation

	callArgs []*UserRepositoryMockWithTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryMockWithTransactionExpectation specifies expectation struct of the UserRepository.WithTransaction
type UserRepositoryMockWithTransactionExpectation struct {
	mock               *UserRepositoryMock
	params             *UserRepositoryMockWithTransactionParams
	paramPtrs          *UserRepositoryMockWithTransactionParamPtrs
	expectationOrigins UserRepositoryMockWithTransactionExpectationOrigins
	results            *UserRepositoryMockWithTransactionResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryMockWithTransactionParams contains parameters of the UserRepository.WithTransaction
type UserRepositoryMockWithTransactionParams struct {
	ctx context.Context
	fn  func(tx pgx.Tx) error
}

// UserRepositoryMockWithTransactionParamPtrs contains pointers to parameters of the UserRepository.WithTransaction
type UserRepositoryMockWithTransactionParamPtrs struct {
	ctx *context.Context
	fn  *func(tx pgx.Tx) error
}

// UserRepositoryMockWithTransactionResults contains results of the UserRepository.WithTransaction
type UserRepositoryMockWithTransactionResults struct {
	err error
}

// UserRepositoryMockWithTransactionOrigins contains origins of expectations of the UserRepository.WithTransaction
type UserRepositoryMockWithTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originFn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Optional() *mUserRepositoryMockWithTransaction {
	mmWithTransaction.optional = true
	return mmWithTransaction
}

// Expect sets up expected params for UserRepository.WithTransaction
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Expect(ctx context.Context, fn func(tx pgx.Tx) error) *mUserRepositoryMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &UserRepositoryMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.paramPtrs != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by ExpectParams functions")
	}

	mmWithTransaction.defaultExpectation.params = &UserRepositoryMockWithTransactionParams{ctx, fn}
	mmWithTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithTransaction.expectations {
		if minimock.Equal(e.params, mmWithTransaction.defaultExpectation.params) {
			mmWithTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithTransaction.defaultExpectation.params)
		}
	}

	return mmWithTransaction
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.WithTransaction
func (mmWithTransaction *mUserRepositoryMockWithTransaction) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &UserRepositoryMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.params != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Expect")
	}

	if mmWithTransaction.defaultExpectation.paramPtrs == nil {
		mmWithTransaction.defaultExpectation.paramPtrs = &UserRepositoryMockWithTransactionParamPtrs{}
	}
	mmWithTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmWithTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWithTransaction
}

// ExpectFnParam2 sets up expected param fn for UserRepository.WithTransaction
func (mmWithTransaction *mUserRepositoryMockWithTransaction) ExpectFnParam2(fn func(tx pgx.Tx) error) *mUserRepositoryMockWithTransaction {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &UserRepositoryMockWithTransactionExpectation{}
	}

	if mmWithTransaction.defaultExpectation.params != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Expect")
	}

	if mmWithTransaction.defaultExpectation.paramPtrs == nil {
		mmWithTransaction.defaultExpectation.paramPtrs = &UserRepositoryMockWithTransactionParamPtrs{}
	}
	mmWithTransaction.defaultExpectation.paramPtrs.fn = &fn
	mmWithTransaction.defaultExpectation.expectationOrigins.originFn = minimock.CallerInfo(1)

	return mmWithTransaction
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.WithTransaction
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Inspect(f func(ctx context.Context, fn func(tx pgx.Tx) error)) *mUserRepositoryMockWithTransaction {
	if mmWithTransaction.mock.inspectFuncWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.WithTransaction")
	}

	mmWithTransaction.mock.inspectFuncWithTransaction = f

	return mmWithTransaction
}

// Return sets up results that will be returned by UserRepository.WithTransaction
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Return(err error) *UserRepositoryMock {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Set")
	}

	if mmWithTransaction.defaultExpectation == nil {
		mmWithTransaction.defaultExpectation = &UserRepositoryMockWithTransactionExpectation{mock: mmWithTransaction.mock}
	}
	mmWithTransaction.defaultExpectation.results = &UserRepositoryMockWithTransactionResults{err}
	mmWithTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithTransaction.mock
}

// Set uses given function f to mock the UserRepository.WithTransaction method
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Set(f func(ctx context.Context, fn func(tx pgx.Tx) error) (err error)) *UserRepositoryMock {
	if mmWithTransaction.defaultExpectation != nil {
		mmWithTransaction.mock.t.Fatalf("Default expectation is already set for the UserRepository.WithTransaction method")
	}

	if len(mmWithTransaction.expectations) > 0 {
		mmWithTransaction.mock.t.Fatalf("Some expectations are already set for the UserRepository.WithTransaction method")
	}

	mmWithTransaction.mock.funcWithTransaction = f
	mmWithTransaction.mock.funcWithTransactionOrigin = minimock.CallerInfo(1)
	return mmWithTransaction.mock
}

// When sets expectation for the UserRepository.WithTransaction which will trigger the result defined by the following
// Then helper
func (mmWithTransaction *mUserRepositoryMockWithTransaction) When(ctx context.Context, fn func(tx pgx.Tx) error) *UserRepositoryMockWithTransactionExpectation {
	if mmWithTransaction.mock.funcWithTransaction != nil {
		mmWithTransaction.mock.t.Fatalf("UserRepositoryMock.WithTransaction mock is already set by Set")
	}

	expectation := &UserRepositoryMockWithTransactionExpectation{
		mock:               mmWithTransaction.mock,
		params:             &UserRepositoryMockWithTransactionParams{ctx, fn},
		expectationOrigins: UserRepositoryMockWithTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithTransaction.expectations = append(mmWithTransaction.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.WithTransaction return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockWithTransactionExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockWithTransactionResults{err}
	return e.mock
}

// Times sets number of times UserRepository.WithTransaction should be invoked
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Times(n uint64) *mUserRepositoryMockWithTransaction {
	if n == 0 {
		mmWithTransaction.mock.t.Fatalf("Times of UserRepositoryMock.WithTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithTransaction.expectedInvocations, n)
	mmWithTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithTransaction
}

func (mmWithTransaction *mUserRepositoryMockWithTransaction) invocationsDone() bool {
	if len(mmWithTransaction.expectations) == 0 && mmWithTransaction.defaultExpectation == nil && mmWithTransaction.mock.funcWithTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithTransaction.mock.afterWithTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithTransaction implements mm_repository.UserRepository
func (mmWithTransaction *UserRepositoryMock) WithTransaction(ctx context.Context, fn func(tx pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmWithTransaction.beforeWithTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmWithTransaction.afterWithTransactionCounter, 1)

	mmWithTransaction.t.Helper()

	if mmWithTransaction.inspectFuncWithTransaction != nil {
		mmWithTransaction.inspectFuncWithTransaction(ctx, fn)
	}

	mm_params := UserRepositoryMockWithTransactionParams{ctx, fn}

	// Record call args
	mmWithTransaction.WithTransactionMock.mutex.Lock()
	mmWithTransaction.WithTransactionMock.callArgs = append(mmWithTransaction.WithTransactionMock.callArgs, &mm_params)
	mmWithTransaction.WithTransactionMock.mutex.Unlock()

	for _, e := range mmWithTransaction.WithTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithTransaction.WithTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithTransaction.WithTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmWithTransaction.WithTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmWithTransaction.WithTransactionMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockWithTransactionParams{ctx, fn}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWithTransaction.t.Errorf("UserRepositoryMock.WithTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fn != nil && !minimock.Equal(*mm_want_ptrs.fn, mm_got.fn) {
				mmWithTransaction.t.Errorf("UserRepositoryMock.WithTransaction got unexpected parameter fn, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.originFn, *mm_want_ptrs.fn, mm_got.fn, minimock.Diff(*mm_want_ptrs.fn, mm_got.fn))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithTransaction.t.Errorf("UserRepositoryMock.WithTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithTransaction.WithTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithTransaction.WithTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmWithTransaction.t.Fatal("No results are set for the UserRepositoryMock.WithTransaction")
		}
		return (*mm_results).err
	}
	if mmWithTransaction.funcWithTransaction != nil {
		return mmWithTransaction.funcWithTransaction(ctx, fn)
	}
	mmWithTransaction.t.Fatalf("Unexpected call to UserRepositoryMock.WithTransaction. %v %v", ctx, fn)
	return
}

// WithTransactionAfterCounter returns a count of finished UserRepositoryMock.WithTransaction invocations
func (mmWithTransaction *UserRepositoryMock) WithTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTransaction.afterWithTransactionCounter)
}

// WithTransactionBeforeCounter returns a count of UserRepositoryMock.WithTransaction invocations
func (mmWithTransaction *UserRepositoryMock) WithTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithTransaction.beforeWithTransactionCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.WithTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithTransaction *mUserRepositoryMockWithTransaction) Calls() []*UserRepositoryMockWithTransactionParams {
	mmWithTransaction.mutex.RLock()

	argCopy := make([]*UserRepositoryMockWithTransactionParams, len(mmWithTransaction.callArgs))
	copy(argCopy, mmWithTransaction.callArgs)

	mmWithTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockWithTransactionDone returns true if the count of the WithTransaction invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockWithTransactionDone() bool {
	if m.WithTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithTransactionMock.invocationsDone()
}

// MinimockWithTransactionInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockWithTransactionInspect() {
	for _, e := range m.WithTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithTransactionCounter := mm_atomic.LoadUint64(&m.afterWithTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithTransactionMock.defaultExpectation != nil && afterWithTransactionCounter < 1 {
		if m.WithTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTransaction at\n%s", m.WithTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.WithTransaction at\n%s with params: %#v", m.WithTransactionMock.defaultExpectation.expectationOrigins.origin, *m.WithTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithTransaction != nil && afterWithTransactionCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryMock.WithTransaction at\n%s", m.funcWithTransactionOrigin)
	}

	if !m.WithTransactionMock.invocationsDone() && afterWithTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.WithTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithTransactionMock.expectedInvocations), m.WithTransactionMock.expectedInvocationsOrigin, afterWithTransactionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCoinsInspect()

			m.MinimockCreateUserInspect()

			m.MinimockGetUserByIDInspect()

			m.MinimockGetUserByUsernameInspect()

			m.MinimockSubtractCoinsInspect()

			m.MinimockWithTransactionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCoinsDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserByUsernameDone() &&
		m.MinimockSubtractCoinsDone() &&
		m.MinimockWithTransactionDone()
}
