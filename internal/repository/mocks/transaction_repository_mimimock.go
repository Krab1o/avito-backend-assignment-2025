// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Krab1o/avito-backend-assignment-2025/internal/repository.TransactionRepository -o transaction_repository_mimimock.go -n TransactionRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	transactionModel "github.com/Krab1o/avito-backend-assignment-2025/internal/repository/transaction/model"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// TransactionRepositoryMock implements mm_repository.TransactionRepository
type TransactionRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateTransaction          func(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction) (err error)
	funcCreateTransactionOrigin    string
	inspectFuncCreateTransaction   func(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction)
	afterCreateTransactionCounter  uint64
	beforeCreateTransactionCounter uint64
	CreateTransactionMock          mTransactionRepositoryMockCreateTransaction

	funcGetTransactionsByReceiverID          func(ctx context.Context, tx pgx.Tx, receiverID int64) (ua1 []transactionModel.UserTransaction, err error)
	funcGetTransactionsByReceiverIDOrigin    string
	inspectFuncGetTransactionsByReceiverID   func(ctx context.Context, tx pgx.Tx, receiverID int64)
	afterGetTransactionsByReceiverIDCounter  uint64
	beforeGetTransactionsByReceiverIDCounter uint64
	GetTransactionsByReceiverIDMock          mTransactionRepositoryMockGetTransactionsByReceiverID

	funcGetTransactionsBySenderID          func(ctx context.Context, tx pgx.Tx, senderID int64) (ua1 []transactionModel.UserTransaction, err error)
	funcGetTransactionsBySenderIDOrigin    string
	inspectFuncGetTransactionsBySenderID   func(ctx context.Context, tx pgx.Tx, senderID int64)
	afterGetTransactionsBySenderIDCounter  uint64
	beforeGetTransactionsBySenderIDCounter uint64
	GetTransactionsBySenderIDMock          mTransactionRepositoryMockGetTransactionsBySenderID
}

// NewTransactionRepositoryMock returns a mock for mm_repository.TransactionRepository
func NewTransactionRepositoryMock(t minimock.Tester) *TransactionRepositoryMock {
	m := &TransactionRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateTransactionMock = mTransactionRepositoryMockCreateTransaction{mock: m}
	m.CreateTransactionMock.callArgs = []*TransactionRepositoryMockCreateTransactionParams{}

	m.GetTransactionsByReceiverIDMock = mTransactionRepositoryMockGetTransactionsByReceiverID{mock: m}
	m.GetTransactionsByReceiverIDMock.callArgs = []*TransactionRepositoryMockGetTransactionsByReceiverIDParams{}

	m.GetTransactionsBySenderIDMock = mTransactionRepositoryMockGetTransactionsBySenderID{mock: m}
	m.GetTransactionsBySenderIDMock.callArgs = []*TransactionRepositoryMockGetTransactionsBySenderIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTransactionRepositoryMockCreateTransaction struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockCreateTransactionExpectation
	expectations       []*TransactionRepositoryMockCreateTransactionExpectation

	callArgs []*TransactionRepositoryMockCreateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockCreateTransactionExpectation specifies expectation struct of the TransactionRepository.CreateTransaction
type TransactionRepositoryMockCreateTransactionExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockCreateTransactionParams
	paramPtrs          *TransactionRepositoryMockCreateTransactionParamPtrs
	expectationOrigins TransactionRepositoryMockCreateTransactionExpectationOrigins
	results            *TransactionRepositoryMockCreateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockCreateTransactionParams contains parameters of the TransactionRepository.CreateTransaction
type TransactionRepositoryMockCreateTransactionParams struct {
	ctx   context.Context
	tx    pgx.Tx
	model *transactionModel.Transaction
}

// TransactionRepositoryMockCreateTransactionParamPtrs contains pointers to parameters of the TransactionRepository.CreateTransaction
type TransactionRepositoryMockCreateTransactionParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	model **transactionModel.Transaction
}

// TransactionRepositoryMockCreateTransactionResults contains results of the TransactionRepository.CreateTransaction
type TransactionRepositoryMockCreateTransactionResults struct {
	err error
}

// TransactionRepositoryMockCreateTransactionOrigins contains origins of expectations of the TransactionRepository.CreateTransaction
type TransactionRepositoryMockCreateTransactionExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Optional() *mTransactionRepositoryMockCreateTransaction {
	mmCreateTransaction.optional = true
	return mmCreateTransaction
}

// Expect sets up expected params for TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Expect(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction) *mTransactionRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &TransactionRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by ExpectParams functions")
	}

	mmCreateTransaction.defaultExpectation.params = &TransactionRepositoryMockCreateTransactionParams{ctx, tx, model}
	mmCreateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTransaction.expectations {
		if minimock.Equal(e.params, mmCreateTransaction.defaultExpectation.params) {
			mmCreateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransaction.defaultExpectation.params)
		}
	}

	return mmCreateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &TransactionRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &TransactionRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectTxParam2 sets up expected param tx for TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) ExpectTxParam2(tx pgx.Tx) *mTransactionRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &TransactionRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &TransactionRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.tx = &tx
	mmCreateTransaction.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectModelParam3 sets up expected param model for TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) ExpectModelParam3(model *transactionModel.Transaction) *mTransactionRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &TransactionRepositoryMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &TransactionRepositoryMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.model = &model
	mmCreateTransaction.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Inspect(f func(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction)) *mTransactionRepositoryMockCreateTransaction {
	if mmCreateTransaction.mock.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.CreateTransaction")
	}

	mmCreateTransaction.mock.inspectFuncCreateTransaction = f

	return mmCreateTransaction
}

// Return sets up results that will be returned by TransactionRepository.CreateTransaction
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Return(err error) *TransactionRepositoryMock {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &TransactionRepositoryMockCreateTransactionExpectation{mock: mmCreateTransaction.mock}
	}
	mmCreateTransaction.defaultExpectation.results = &TransactionRepositoryMockCreateTransactionResults{err}
	mmCreateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// Set uses given function f to mock the TransactionRepository.CreateTransaction method
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Set(f func(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction) (err error)) *TransactionRepositoryMock {
	if mmCreateTransaction.defaultExpectation != nil {
		mmCreateTransaction.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.CreateTransaction method")
	}

	if len(mmCreateTransaction.expectations) > 0 {
		mmCreateTransaction.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.CreateTransaction method")
	}

	mmCreateTransaction.mock.funcCreateTransaction = f
	mmCreateTransaction.mock.funcCreateTransactionOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// When sets expectation for the TransactionRepository.CreateTransaction which will trigger the result defined by the following
// Then helper
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) When(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction) *TransactionRepositoryMockCreateTransactionExpectation {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("TransactionRepositoryMock.CreateTransaction mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockCreateTransactionExpectation{
		mock:               mmCreateTransaction.mock,
		params:             &TransactionRepositoryMockCreateTransactionParams{ctx, tx, model},
		expectationOrigins: TransactionRepositoryMockCreateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTransaction.expectations = append(mmCreateTransaction.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.CreateTransaction return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockCreateTransactionExpectation) Then(err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockCreateTransactionResults{err}
	return e.mock
}

// Times sets number of times TransactionRepository.CreateTransaction should be invoked
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Times(n uint64) *mTransactionRepositoryMockCreateTransaction {
	if n == 0 {
		mmCreateTransaction.mock.t.Fatalf("Times of TransactionRepositoryMock.CreateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTransaction.expectedInvocations, n)
	mmCreateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction
}

func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) invocationsDone() bool {
	if len(mmCreateTransaction.expectations) == 0 && mmCreateTransaction.defaultExpectation == nil && mmCreateTransaction.mock.funcCreateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.mock.afterCreateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTransaction implements mm_repository.TransactionRepository
func (mmCreateTransaction *TransactionRepositoryMock) CreateTransaction(ctx context.Context, tx pgx.Tx, model *transactionModel.Transaction) (err error) {
	mm_atomic.AddUint64(&mmCreateTransaction.beforeCreateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTransaction.afterCreateTransactionCounter, 1)

	mmCreateTransaction.t.Helper()

	if mmCreateTransaction.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.inspectFuncCreateTransaction(ctx, tx, model)
	}

	mm_params := TransactionRepositoryMockCreateTransactionParams{ctx, tx, model}

	// Record call args
	mmCreateTransaction.CreateTransactionMock.mutex.Lock()
	mmCreateTransaction.CreateTransactionMock.callArgs = append(mmCreateTransaction.CreateTransactionMock.callArgs, &mm_params)
	mmCreateTransaction.CreateTransactionMock.mutex.Unlock()

	for _, e := range mmCreateTransaction.CreateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateTransaction.CreateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTransaction.CreateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTransaction.CreateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTransaction.CreateTransactionMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockCreateTransactionParams{ctx, tx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTransaction.t.Errorf("TransactionRepositoryMock.CreateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmCreateTransaction.t.Errorf("TransactionRepositoryMock.CreateTransaction got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreateTransaction.t.Errorf("TransactionRepositoryMock.CreateTransaction got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTransaction.t.Errorf("TransactionRepositoryMock.CreateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTransaction.CreateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTransaction.t.Fatal("No results are set for the TransactionRepositoryMock.CreateTransaction")
		}
		return (*mm_results).err
	}
	if mmCreateTransaction.funcCreateTransaction != nil {
		return mmCreateTransaction.funcCreateTransaction(ctx, tx, model)
	}
	mmCreateTransaction.t.Fatalf("Unexpected call to TransactionRepositoryMock.CreateTransaction. %v %v %v", ctx, tx, model)
	return
}

// CreateTransactionAfterCounter returns a count of finished TransactionRepositoryMock.CreateTransaction invocations
func (mmCreateTransaction *TransactionRepositoryMock) CreateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.afterCreateTransactionCounter)
}

// CreateTransactionBeforeCounter returns a count of TransactionRepositoryMock.CreateTransaction invocations
func (mmCreateTransaction *TransactionRepositoryMock) CreateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.beforeCreateTransactionCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.CreateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransaction *mTransactionRepositoryMockCreateTransaction) Calls() []*TransactionRepositoryMockCreateTransactionParams {
	mmCreateTransaction.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockCreateTransactionParams, len(mmCreateTransaction.callArgs))
	copy(argCopy, mmCreateTransaction.callArgs)

	mmCreateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTransactionDone returns true if the count of the CreateTransaction invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockCreateTransactionDone() bool {
	if m.CreateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTransactionMock.invocationsDone()
}

// MinimockCreateTransactionInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockCreateTransactionInspect() {
	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CreateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTransactionCounter := mm_atomic.LoadUint64(&m.afterCreateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTransactionMock.defaultExpectation != nil && afterCreateTransactionCounter < 1 {
		if m.CreateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CreateTransaction at\n%s", m.CreateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.CreateTransaction at\n%s with params: %#v", m.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTransaction != nil && afterCreateTransactionCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.CreateTransaction at\n%s", m.funcCreateTransactionOrigin)
	}

	if !m.CreateTransactionMock.invocationsDone() && afterCreateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.CreateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTransactionMock.expectedInvocations), m.CreateTransactionMock.expectedInvocationsOrigin, afterCreateTransactionCounter)
	}
}

type mTransactionRepositoryMockGetTransactionsByReceiverID struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockGetTransactionsByReceiverIDExpectation
	expectations       []*TransactionRepositoryMockGetTransactionsByReceiverIDExpectation

	callArgs []*TransactionRepositoryMockGetTransactionsByReceiverIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockGetTransactionsByReceiverIDExpectation specifies expectation struct of the TransactionRepository.GetTransactionsByReceiverID
type TransactionRepositoryMockGetTransactionsByReceiverIDExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockGetTransactionsByReceiverIDParams
	paramPtrs          *TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs
	expectationOrigins TransactionRepositoryMockGetTransactionsByReceiverIDExpectationOrigins
	results            *TransactionRepositoryMockGetTransactionsByReceiverIDResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockGetTransactionsByReceiverIDParams contains parameters of the TransactionRepository.GetTransactionsByReceiverID
type TransactionRepositoryMockGetTransactionsByReceiverIDParams struct {
	ctx        context.Context
	tx         pgx.Tx
	receiverID int64
}

// TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs contains pointers to parameters of the TransactionRepository.GetTransactionsByReceiverID
type TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs struct {
	ctx        *context.Context
	tx         *pgx.Tx
	receiverID *int64
}

// TransactionRepositoryMockGetTransactionsByReceiverIDResults contains results of the TransactionRepository.GetTransactionsByReceiverID
type TransactionRepositoryMockGetTransactionsByReceiverIDResults struct {
	ua1 []transactionModel.UserTransaction
	err error
}

// TransactionRepositoryMockGetTransactionsByReceiverIDOrigins contains origins of expectations of the TransactionRepository.GetTransactionsByReceiverID
type TransactionRepositoryMockGetTransactionsByReceiverIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originTx         string
	originReceiverID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Optional() *mTransactionRepositoryMockGetTransactionsByReceiverID {
	mmGetTransactionsByReceiverID.optional = true
	return mmGetTransactionsByReceiverID
}

// Expect sets up expected params for TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Expect(ctx context.Context, tx pgx.Tx, receiverID int64) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation == nil {
		mmGetTransactionsByReceiverID.defaultExpectation = &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{}
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by ExpectParams functions")
	}

	mmGetTransactionsByReceiverID.defaultExpectation.params = &TransactionRepositoryMockGetTransactionsByReceiverIDParams{ctx, tx, receiverID}
	mmGetTransactionsByReceiverID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTransactionsByReceiverID.expectations {
		if minimock.Equal(e.params, mmGetTransactionsByReceiverID.defaultExpectation.params) {
			mmGetTransactionsByReceiverID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTransactionsByReceiverID.defaultExpectation.params)
		}
	}

	return mmGetTransactionsByReceiverID
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation == nil {
		mmGetTransactionsByReceiverID.defaultExpectation = &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{}
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.params != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Expect")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs{}
	}
	mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTransactionsByReceiverID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTransactionsByReceiverID
}

// ExpectTxParam2 sets up expected param tx for TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) ExpectTxParam2(tx pgx.Tx) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation == nil {
		mmGetTransactionsByReceiverID.defaultExpectation = &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{}
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.params != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Expect")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs{}
	}
	mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs.tx = &tx
	mmGetTransactionsByReceiverID.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmGetTransactionsByReceiverID
}

// ExpectReceiverIDParam3 sets up expected param receiverID for TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) ExpectReceiverIDParam3(receiverID int64) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation == nil {
		mmGetTransactionsByReceiverID.defaultExpectation = &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{}
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.params != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Expect")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsByReceiverIDParamPtrs{}
	}
	mmGetTransactionsByReceiverID.defaultExpectation.paramPtrs.receiverID = &receiverID
	mmGetTransactionsByReceiverID.defaultExpectation.expectationOrigins.originReceiverID = minimock.CallerInfo(1)

	return mmGetTransactionsByReceiverID
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Inspect(f func(ctx context.Context, tx pgx.Tx, receiverID int64)) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if mmGetTransactionsByReceiverID.mock.inspectFuncGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.GetTransactionsByReceiverID")
	}

	mmGetTransactionsByReceiverID.mock.inspectFuncGetTransactionsByReceiverID = f

	return mmGetTransactionsByReceiverID
}

// Return sets up results that will be returned by TransactionRepository.GetTransactionsByReceiverID
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Return(ua1 []transactionModel.UserTransaction, err error) *TransactionRepositoryMock {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	if mmGetTransactionsByReceiverID.defaultExpectation == nil {
		mmGetTransactionsByReceiverID.defaultExpectation = &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{mock: mmGetTransactionsByReceiverID.mock}
	}
	mmGetTransactionsByReceiverID.defaultExpectation.results = &TransactionRepositoryMockGetTransactionsByReceiverIDResults{ua1, err}
	mmGetTransactionsByReceiverID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsByReceiverID.mock
}

// Set uses given function f to mock the TransactionRepository.GetTransactionsByReceiverID method
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Set(f func(ctx context.Context, tx pgx.Tx, receiverID int64) (ua1 []transactionModel.UserTransaction, err error)) *TransactionRepositoryMock {
	if mmGetTransactionsByReceiverID.defaultExpectation != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.GetTransactionsByReceiverID method")
	}

	if len(mmGetTransactionsByReceiverID.expectations) > 0 {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.GetTransactionsByReceiverID method")
	}

	mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID = f
	mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverIDOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsByReceiverID.mock
}

// When sets expectation for the TransactionRepository.GetTransactionsByReceiverID which will trigger the result defined by the following
// Then helper
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) When(ctx context.Context, tx pgx.Tx, receiverID int64) *TransactionRepositoryMockGetTransactionsByReceiverIDExpectation {
	if mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsByReceiverID mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockGetTransactionsByReceiverIDExpectation{
		mock:               mmGetTransactionsByReceiverID.mock,
		params:             &TransactionRepositoryMockGetTransactionsByReceiverIDParams{ctx, tx, receiverID},
		expectationOrigins: TransactionRepositoryMockGetTransactionsByReceiverIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTransactionsByReceiverID.expectations = append(mmGetTransactionsByReceiverID.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.GetTransactionsByReceiverID return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockGetTransactionsByReceiverIDExpectation) Then(ua1 []transactionModel.UserTransaction, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockGetTransactionsByReceiverIDResults{ua1, err}
	return e.mock
}

// Times sets number of times TransactionRepository.GetTransactionsByReceiverID should be invoked
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Times(n uint64) *mTransactionRepositoryMockGetTransactionsByReceiverID {
	if n == 0 {
		mmGetTransactionsByReceiverID.mock.t.Fatalf("Times of TransactionRepositoryMock.GetTransactionsByReceiverID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTransactionsByReceiverID.expectedInvocations, n)
	mmGetTransactionsByReceiverID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsByReceiverID
}

func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) invocationsDone() bool {
	if len(mmGetTransactionsByReceiverID.expectations) == 0 && mmGetTransactionsByReceiverID.defaultExpectation == nil && mmGetTransactionsByReceiverID.mock.funcGetTransactionsByReceiverID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTransactionsByReceiverID.mock.afterGetTransactionsByReceiverIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTransactionsByReceiverID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTransactionsByReceiverID implements mm_repository.TransactionRepository
func (mmGetTransactionsByReceiverID *TransactionRepositoryMock) GetTransactionsByReceiverID(ctx context.Context, tx pgx.Tx, receiverID int64) (ua1 []transactionModel.UserTransaction, err error) {
	mm_atomic.AddUint64(&mmGetTransactionsByReceiverID.beforeGetTransactionsByReceiverIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTransactionsByReceiverID.afterGetTransactionsByReceiverIDCounter, 1)

	mmGetTransactionsByReceiverID.t.Helper()

	if mmGetTransactionsByReceiverID.inspectFuncGetTransactionsByReceiverID != nil {
		mmGetTransactionsByReceiverID.inspectFuncGetTransactionsByReceiverID(ctx, tx, receiverID)
	}

	mm_params := TransactionRepositoryMockGetTransactionsByReceiverIDParams{ctx, tx, receiverID}

	// Record call args
	mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.mutex.Lock()
	mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.callArgs = append(mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.callArgs, &mm_params)
	mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.mutex.Unlock()

	for _, e := range mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockGetTransactionsByReceiverIDParams{ctx, tx, receiverID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTransactionsByReceiverID.t.Errorf("TransactionRepositoryMock.GetTransactionsByReceiverID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmGetTransactionsByReceiverID.t.Errorf("TransactionRepositoryMock.GetTransactionsByReceiverID got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.receiverID != nil && !minimock.Equal(*mm_want_ptrs.receiverID, mm_got.receiverID) {
				mmGetTransactionsByReceiverID.t.Errorf("TransactionRepositoryMock.GetTransactionsByReceiverID got unexpected parameter receiverID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.expectationOrigins.originReceiverID, *mm_want_ptrs.receiverID, mm_got.receiverID, minimock.Diff(*mm_want_ptrs.receiverID, mm_got.receiverID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTransactionsByReceiverID.t.Errorf("TransactionRepositoryMock.GetTransactionsByReceiverID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTransactionsByReceiverID.GetTransactionsByReceiverIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTransactionsByReceiverID.t.Fatal("No results are set for the TransactionRepositoryMock.GetTransactionsByReceiverID")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetTransactionsByReceiverID.funcGetTransactionsByReceiverID != nil {
		return mmGetTransactionsByReceiverID.funcGetTransactionsByReceiverID(ctx, tx, receiverID)
	}
	mmGetTransactionsByReceiverID.t.Fatalf("Unexpected call to TransactionRepositoryMock.GetTransactionsByReceiverID. %v %v %v", ctx, tx, receiverID)
	return
}

// GetTransactionsByReceiverIDAfterCounter returns a count of finished TransactionRepositoryMock.GetTransactionsByReceiverID invocations
func (mmGetTransactionsByReceiverID *TransactionRepositoryMock) GetTransactionsByReceiverIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTransactionsByReceiverID.afterGetTransactionsByReceiverIDCounter)
}

// GetTransactionsByReceiverIDBeforeCounter returns a count of TransactionRepositoryMock.GetTransactionsByReceiverID invocations
func (mmGetTransactionsByReceiverID *TransactionRepositoryMock) GetTransactionsByReceiverIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTransactionsByReceiverID.beforeGetTransactionsByReceiverIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.GetTransactionsByReceiverID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTransactionsByReceiverID *mTransactionRepositoryMockGetTransactionsByReceiverID) Calls() []*TransactionRepositoryMockGetTransactionsByReceiverIDParams {
	mmGetTransactionsByReceiverID.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockGetTransactionsByReceiverIDParams, len(mmGetTransactionsByReceiverID.callArgs))
	copy(argCopy, mmGetTransactionsByReceiverID.callArgs)

	mmGetTransactionsByReceiverID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTransactionsByReceiverIDDone returns true if the count of the GetTransactionsByReceiverID invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockGetTransactionsByReceiverIDDone() bool {
	if m.GetTransactionsByReceiverIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTransactionsByReceiverIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTransactionsByReceiverIDMock.invocationsDone()
}

// MinimockGetTransactionsByReceiverIDInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockGetTransactionsByReceiverIDInspect() {
	for _, e := range m.GetTransactionsByReceiverIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsByReceiverID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTransactionsByReceiverIDCounter := mm_atomic.LoadUint64(&m.afterGetTransactionsByReceiverIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTransactionsByReceiverIDMock.defaultExpectation != nil && afterGetTransactionsByReceiverIDCounter < 1 {
		if m.GetTransactionsByReceiverIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsByReceiverID at\n%s", m.GetTransactionsByReceiverIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsByReceiverID at\n%s with params: %#v", m.GetTransactionsByReceiverIDMock.defaultExpectation.expectationOrigins.origin, *m.GetTransactionsByReceiverIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTransactionsByReceiverID != nil && afterGetTransactionsByReceiverIDCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsByReceiverID at\n%s", m.funcGetTransactionsByReceiverIDOrigin)
	}

	if !m.GetTransactionsByReceiverIDMock.invocationsDone() && afterGetTransactionsByReceiverIDCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.GetTransactionsByReceiverID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTransactionsByReceiverIDMock.expectedInvocations), m.GetTransactionsByReceiverIDMock.expectedInvocationsOrigin, afterGetTransactionsByReceiverIDCounter)
	}
}

type mTransactionRepositoryMockGetTransactionsBySenderID struct {
	optional           bool
	mock               *TransactionRepositoryMock
	defaultExpectation *TransactionRepositoryMockGetTransactionsBySenderIDExpectation
	expectations       []*TransactionRepositoryMockGetTransactionsBySenderIDExpectation

	callArgs []*TransactionRepositoryMockGetTransactionsBySenderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TransactionRepositoryMockGetTransactionsBySenderIDExpectation specifies expectation struct of the TransactionRepository.GetTransactionsBySenderID
type TransactionRepositoryMockGetTransactionsBySenderIDExpectation struct {
	mock               *TransactionRepositoryMock
	params             *TransactionRepositoryMockGetTransactionsBySenderIDParams
	paramPtrs          *TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs
	expectationOrigins TransactionRepositoryMockGetTransactionsBySenderIDExpectationOrigins
	results            *TransactionRepositoryMockGetTransactionsBySenderIDResults
	returnOrigin       string
	Counter            uint64
}

// TransactionRepositoryMockGetTransactionsBySenderIDParams contains parameters of the TransactionRepository.GetTransactionsBySenderID
type TransactionRepositoryMockGetTransactionsBySenderIDParams struct {
	ctx      context.Context
	tx       pgx.Tx
	senderID int64
}

// TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs contains pointers to parameters of the TransactionRepository.GetTransactionsBySenderID
type TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs struct {
	ctx      *context.Context
	tx       *pgx.Tx
	senderID *int64
}

// TransactionRepositoryMockGetTransactionsBySenderIDResults contains results of the TransactionRepository.GetTransactionsBySenderID
type TransactionRepositoryMockGetTransactionsBySenderIDResults struct {
	ua1 []transactionModel.UserTransaction
	err error
}

// TransactionRepositoryMockGetTransactionsBySenderIDOrigins contains origins of expectations of the TransactionRepository.GetTransactionsBySenderID
type TransactionRepositoryMockGetTransactionsBySenderIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originTx       string
	originSenderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Optional() *mTransactionRepositoryMockGetTransactionsBySenderID {
	mmGetTransactionsBySenderID.optional = true
	return mmGetTransactionsBySenderID
}

// Expect sets up expected params for TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Expect(ctx context.Context, tx pgx.Tx, senderID int64) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	if mmGetTransactionsBySenderID.defaultExpectation == nil {
		mmGetTransactionsBySenderID.defaultExpectation = &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{}
	}

	if mmGetTransactionsBySenderID.defaultExpectation.paramPtrs != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by ExpectParams functions")
	}

	mmGetTransactionsBySenderID.defaultExpectation.params = &TransactionRepositoryMockGetTransactionsBySenderIDParams{ctx, tx, senderID}
	mmGetTransactionsBySenderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTransactionsBySenderID.expectations {
		if minimock.Equal(e.params, mmGetTransactionsBySenderID.defaultExpectation.params) {
			mmGetTransactionsBySenderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTransactionsBySenderID.defaultExpectation.params)
		}
	}

	return mmGetTransactionsBySenderID
}

// ExpectCtxParam1 sets up expected param ctx for TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) ExpectCtxParam1(ctx context.Context) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	if mmGetTransactionsBySenderID.defaultExpectation == nil {
		mmGetTransactionsBySenderID.defaultExpectation = &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{}
	}

	if mmGetTransactionsBySenderID.defaultExpectation.params != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Expect")
	}

	if mmGetTransactionsBySenderID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsBySenderID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs{}
	}
	mmGetTransactionsBySenderID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTransactionsBySenderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTransactionsBySenderID
}

// ExpectTxParam2 sets up expected param tx for TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) ExpectTxParam2(tx pgx.Tx) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	if mmGetTransactionsBySenderID.defaultExpectation == nil {
		mmGetTransactionsBySenderID.defaultExpectation = &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{}
	}

	if mmGetTransactionsBySenderID.defaultExpectation.params != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Expect")
	}

	if mmGetTransactionsBySenderID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsBySenderID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs{}
	}
	mmGetTransactionsBySenderID.defaultExpectation.paramPtrs.tx = &tx
	mmGetTransactionsBySenderID.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmGetTransactionsBySenderID
}

// ExpectSenderIDParam3 sets up expected param senderID for TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) ExpectSenderIDParam3(senderID int64) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	if mmGetTransactionsBySenderID.defaultExpectation == nil {
		mmGetTransactionsBySenderID.defaultExpectation = &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{}
	}

	if mmGetTransactionsBySenderID.defaultExpectation.params != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Expect")
	}

	if mmGetTransactionsBySenderID.defaultExpectation.paramPtrs == nil {
		mmGetTransactionsBySenderID.defaultExpectation.paramPtrs = &TransactionRepositoryMockGetTransactionsBySenderIDParamPtrs{}
	}
	mmGetTransactionsBySenderID.defaultExpectation.paramPtrs.senderID = &senderID
	mmGetTransactionsBySenderID.defaultExpectation.expectationOrigins.originSenderID = minimock.CallerInfo(1)

	return mmGetTransactionsBySenderID
}

// Inspect accepts an inspector function that has same arguments as the TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Inspect(f func(ctx context.Context, tx pgx.Tx, senderID int64)) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if mmGetTransactionsBySenderID.mock.inspectFuncGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("Inspect function is already set for TransactionRepositoryMock.GetTransactionsBySenderID")
	}

	mmGetTransactionsBySenderID.mock.inspectFuncGetTransactionsBySenderID = f

	return mmGetTransactionsBySenderID
}

// Return sets up results that will be returned by TransactionRepository.GetTransactionsBySenderID
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Return(ua1 []transactionModel.UserTransaction, err error) *TransactionRepositoryMock {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	if mmGetTransactionsBySenderID.defaultExpectation == nil {
		mmGetTransactionsBySenderID.defaultExpectation = &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{mock: mmGetTransactionsBySenderID.mock}
	}
	mmGetTransactionsBySenderID.defaultExpectation.results = &TransactionRepositoryMockGetTransactionsBySenderIDResults{ua1, err}
	mmGetTransactionsBySenderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsBySenderID.mock
}

// Set uses given function f to mock the TransactionRepository.GetTransactionsBySenderID method
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Set(f func(ctx context.Context, tx pgx.Tx, senderID int64) (ua1 []transactionModel.UserTransaction, err error)) *TransactionRepositoryMock {
	if mmGetTransactionsBySenderID.defaultExpectation != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("Default expectation is already set for the TransactionRepository.GetTransactionsBySenderID method")
	}

	if len(mmGetTransactionsBySenderID.expectations) > 0 {
		mmGetTransactionsBySenderID.mock.t.Fatalf("Some expectations are already set for the TransactionRepository.GetTransactionsBySenderID method")
	}

	mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID = f
	mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderIDOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsBySenderID.mock
}

// When sets expectation for the TransactionRepository.GetTransactionsBySenderID which will trigger the result defined by the following
// Then helper
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) When(ctx context.Context, tx pgx.Tx, senderID int64) *TransactionRepositoryMockGetTransactionsBySenderIDExpectation {
	if mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.mock.t.Fatalf("TransactionRepositoryMock.GetTransactionsBySenderID mock is already set by Set")
	}

	expectation := &TransactionRepositoryMockGetTransactionsBySenderIDExpectation{
		mock:               mmGetTransactionsBySenderID.mock,
		params:             &TransactionRepositoryMockGetTransactionsBySenderIDParams{ctx, tx, senderID},
		expectationOrigins: TransactionRepositoryMockGetTransactionsBySenderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTransactionsBySenderID.expectations = append(mmGetTransactionsBySenderID.expectations, expectation)
	return expectation
}

// Then sets up TransactionRepository.GetTransactionsBySenderID return parameters for the expectation previously defined by the When method
func (e *TransactionRepositoryMockGetTransactionsBySenderIDExpectation) Then(ua1 []transactionModel.UserTransaction, err error) *TransactionRepositoryMock {
	e.results = &TransactionRepositoryMockGetTransactionsBySenderIDResults{ua1, err}
	return e.mock
}

// Times sets number of times TransactionRepository.GetTransactionsBySenderID should be invoked
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Times(n uint64) *mTransactionRepositoryMockGetTransactionsBySenderID {
	if n == 0 {
		mmGetTransactionsBySenderID.mock.t.Fatalf("Times of TransactionRepositoryMock.GetTransactionsBySenderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTransactionsBySenderID.expectedInvocations, n)
	mmGetTransactionsBySenderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTransactionsBySenderID
}

func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) invocationsDone() bool {
	if len(mmGetTransactionsBySenderID.expectations) == 0 && mmGetTransactionsBySenderID.defaultExpectation == nil && mmGetTransactionsBySenderID.mock.funcGetTransactionsBySenderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTransactionsBySenderID.mock.afterGetTransactionsBySenderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTransactionsBySenderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTransactionsBySenderID implements mm_repository.TransactionRepository
func (mmGetTransactionsBySenderID *TransactionRepositoryMock) GetTransactionsBySenderID(ctx context.Context, tx pgx.Tx, senderID int64) (ua1 []transactionModel.UserTransaction, err error) {
	mm_atomic.AddUint64(&mmGetTransactionsBySenderID.beforeGetTransactionsBySenderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTransactionsBySenderID.afterGetTransactionsBySenderIDCounter, 1)

	mmGetTransactionsBySenderID.t.Helper()

	if mmGetTransactionsBySenderID.inspectFuncGetTransactionsBySenderID != nil {
		mmGetTransactionsBySenderID.inspectFuncGetTransactionsBySenderID(ctx, tx, senderID)
	}

	mm_params := TransactionRepositoryMockGetTransactionsBySenderIDParams{ctx, tx, senderID}

	// Record call args
	mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.mutex.Lock()
	mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.callArgs = append(mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.callArgs, &mm_params)
	mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.mutex.Unlock()

	for _, e := range mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.paramPtrs

		mm_got := TransactionRepositoryMockGetTransactionsBySenderIDParams{ctx, tx, senderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTransactionsBySenderID.t.Errorf("TransactionRepositoryMock.GetTransactionsBySenderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmGetTransactionsBySenderID.t.Errorf("TransactionRepositoryMock.GetTransactionsBySenderID got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.senderID != nil && !minimock.Equal(*mm_want_ptrs.senderID, mm_got.senderID) {
				mmGetTransactionsBySenderID.t.Errorf("TransactionRepositoryMock.GetTransactionsBySenderID got unexpected parameter senderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.expectationOrigins.originSenderID, *mm_want_ptrs.senderID, mm_got.senderID, minimock.Diff(*mm_want_ptrs.senderID, mm_got.senderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTransactionsBySenderID.t.Errorf("TransactionRepositoryMock.GetTransactionsBySenderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTransactionsBySenderID.GetTransactionsBySenderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTransactionsBySenderID.t.Fatal("No results are set for the TransactionRepositoryMock.GetTransactionsBySenderID")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetTransactionsBySenderID.funcGetTransactionsBySenderID != nil {
		return mmGetTransactionsBySenderID.funcGetTransactionsBySenderID(ctx, tx, senderID)
	}
	mmGetTransactionsBySenderID.t.Fatalf("Unexpected call to TransactionRepositoryMock.GetTransactionsBySenderID. %v %v %v", ctx, tx, senderID)
	return
}

// GetTransactionsBySenderIDAfterCounter returns a count of finished TransactionRepositoryMock.GetTransactionsBySenderID invocations
func (mmGetTransactionsBySenderID *TransactionRepositoryMock) GetTransactionsBySenderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTransactionsBySenderID.afterGetTransactionsBySenderIDCounter)
}

// GetTransactionsBySenderIDBeforeCounter returns a count of TransactionRepositoryMock.GetTransactionsBySenderID invocations
func (mmGetTransactionsBySenderID *TransactionRepositoryMock) GetTransactionsBySenderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTransactionsBySenderID.beforeGetTransactionsBySenderIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionRepositoryMock.GetTransactionsBySenderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTransactionsBySenderID *mTransactionRepositoryMockGetTransactionsBySenderID) Calls() []*TransactionRepositoryMockGetTransactionsBySenderIDParams {
	mmGetTransactionsBySenderID.mutex.RLock()

	argCopy := make([]*TransactionRepositoryMockGetTransactionsBySenderIDParams, len(mmGetTransactionsBySenderID.callArgs))
	copy(argCopy, mmGetTransactionsBySenderID.callArgs)

	mmGetTransactionsBySenderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTransactionsBySenderIDDone returns true if the count of the GetTransactionsBySenderID invocations corresponds
// the number of defined expectations
func (m *TransactionRepositoryMock) MinimockGetTransactionsBySenderIDDone() bool {
	if m.GetTransactionsBySenderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTransactionsBySenderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTransactionsBySenderIDMock.invocationsDone()
}

// MinimockGetTransactionsBySenderIDInspect logs each unmet expectation
func (m *TransactionRepositoryMock) MinimockGetTransactionsBySenderIDInspect() {
	for _, e := range m.GetTransactionsBySenderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsBySenderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTransactionsBySenderIDCounter := mm_atomic.LoadUint64(&m.afterGetTransactionsBySenderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTransactionsBySenderIDMock.defaultExpectation != nil && afterGetTransactionsBySenderIDCounter < 1 {
		if m.GetTransactionsBySenderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsBySenderID at\n%s", m.GetTransactionsBySenderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsBySenderID at\n%s with params: %#v", m.GetTransactionsBySenderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetTransactionsBySenderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTransactionsBySenderID != nil && afterGetTransactionsBySenderIDCounter < 1 {
		m.t.Errorf("Expected call to TransactionRepositoryMock.GetTransactionsBySenderID at\n%s", m.funcGetTransactionsBySenderIDOrigin)
	}

	if !m.GetTransactionsBySenderIDMock.invocationsDone() && afterGetTransactionsBySenderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to TransactionRepositoryMock.GetTransactionsBySenderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTransactionsBySenderIDMock.expectedInvocations), m.GetTransactionsBySenderIDMock.expectedInvocationsOrigin, afterGetTransactionsBySenderIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateTransactionInspect()

			m.MinimockGetTransactionsByReceiverIDInspect()

			m.MinimockGetTransactionsBySenderIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateTransactionDone() &&
		m.MinimockGetTransactionsByReceiverIDDone() &&
		m.MinimockGetTransactionsBySenderIDDone()
}
