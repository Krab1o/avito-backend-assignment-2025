// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Krab1o/avito-backend-assignment-2025/internal/repository.InventoryRepository -o inventory_repository_mimimock.go -n InventoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Krab1o/avito-backend-assignment-2025/internal/repository/inventory/model"
	inventoryModel "github.com/Krab1o/avito-backend-assignment-2025/internal/repository/inventory/model"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// InventoryRepositoryMock implements mm_repository.InventoryRepository
type InventoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBuyItem          func(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying) (err error)
	funcBuyItemOrigin    string
	inspectFuncBuyItem   func(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying)
	afterBuyItemCounter  uint64
	beforeBuyItemCounter uint64
	BuyItemMock          mInventoryRepositoryMockBuyItem

	funcGetInventoryByID          func(ctx context.Context, tx pgx.Tx, ownerID int64) (i1 model.Inventory, err error)
	funcGetInventoryByIDOrigin    string
	inspectFuncGetInventoryByID   func(ctx context.Context, tx pgx.Tx, ownerID int64)
	afterGetInventoryByIDCounter  uint64
	beforeGetInventoryByIDCounter uint64
	GetInventoryByIDMock          mInventoryRepositoryMockGetInventoryByID
}

// NewInventoryRepositoryMock returns a mock for mm_repository.InventoryRepository
func NewInventoryRepositoryMock(t minimock.Tester) *InventoryRepositoryMock {
	m := &InventoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuyItemMock = mInventoryRepositoryMockBuyItem{mock: m}
	m.BuyItemMock.callArgs = []*InventoryRepositoryMockBuyItemParams{}

	m.GetInventoryByIDMock = mInventoryRepositoryMockGetInventoryByID{mock: m}
	m.GetInventoryByIDMock.callArgs = []*InventoryRepositoryMockGetInventoryByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mInventoryRepositoryMockBuyItem struct {
	optional           bool
	mock               *InventoryRepositoryMock
	defaultExpectation *InventoryRepositoryMockBuyItemExpectation
	expectations       []*InventoryRepositoryMockBuyItemExpectation

	callArgs []*InventoryRepositoryMockBuyItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InventoryRepositoryMockBuyItemExpectation specifies expectation struct of the InventoryRepository.BuyItem
type InventoryRepositoryMockBuyItemExpectation struct {
	mock               *InventoryRepositoryMock
	params             *InventoryRepositoryMockBuyItemParams
	paramPtrs          *InventoryRepositoryMockBuyItemParamPtrs
	expectationOrigins InventoryRepositoryMockBuyItemExpectationOrigins
	results            *InventoryRepositoryMockBuyItemResults
	returnOrigin       string
	Counter            uint64
}

// InventoryRepositoryMockBuyItemParams contains parameters of the InventoryRepository.BuyItem
type InventoryRepositoryMockBuyItemParams struct {
	ctx    context.Context
	tx     pgx.Tx
	buying *inventoryModel.Buying
}

// InventoryRepositoryMockBuyItemParamPtrs contains pointers to parameters of the InventoryRepository.BuyItem
type InventoryRepositoryMockBuyItemParamPtrs struct {
	ctx    *context.Context
	tx     *pgx.Tx
	buying **inventoryModel.Buying
}

// InventoryRepositoryMockBuyItemResults contains results of the InventoryRepository.BuyItem
type InventoryRepositoryMockBuyItemResults struct {
	err error
}

// InventoryRepositoryMockBuyItemOrigins contains origins of expectations of the InventoryRepository.BuyItem
type InventoryRepositoryMockBuyItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originTx     string
	originBuying string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Optional() *mInventoryRepositoryMockBuyItem {
	mmBuyItem.optional = true
	return mmBuyItem
}

// Expect sets up expected params for InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Expect(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying) *mInventoryRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &InventoryRepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.paramPtrs != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by ExpectParams functions")
	}

	mmBuyItem.defaultExpectation.params = &InventoryRepositoryMockBuyItemParams{ctx, tx, buying}
	mmBuyItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuyItem.expectations {
		if minimock.Equal(e.params, mmBuyItem.defaultExpectation.params) {
			mmBuyItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuyItem.defaultExpectation.params)
		}
	}

	return mmBuyItem
}

// ExpectCtxParam1 sets up expected param ctx for InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) ExpectCtxParam1(ctx context.Context) *mInventoryRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &InventoryRepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &InventoryRepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuyItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectTxParam2 sets up expected param tx for InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) ExpectTxParam2(tx pgx.Tx) *mInventoryRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &InventoryRepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &InventoryRepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.tx = &tx
	mmBuyItem.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectBuyingParam3 sets up expected param buying for InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) ExpectBuyingParam3(buying *inventoryModel.Buying) *mInventoryRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &InventoryRepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &InventoryRepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.buying = &buying
	mmBuyItem.defaultExpectation.expectationOrigins.originBuying = minimock.CallerInfo(1)

	return mmBuyItem
}

// Inspect accepts an inspector function that has same arguments as the InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Inspect(f func(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying)) *mInventoryRepositoryMockBuyItem {
	if mmBuyItem.mock.inspectFuncBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("Inspect function is already set for InventoryRepositoryMock.BuyItem")
	}

	mmBuyItem.mock.inspectFuncBuyItem = f

	return mmBuyItem
}

// Return sets up results that will be returned by InventoryRepository.BuyItem
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Return(err error) *InventoryRepositoryMock {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &InventoryRepositoryMockBuyItemExpectation{mock: mmBuyItem.mock}
	}
	mmBuyItem.defaultExpectation.results = &InventoryRepositoryMockBuyItemResults{err}
	mmBuyItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// Set uses given function f to mock the InventoryRepository.BuyItem method
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Set(f func(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying) (err error)) *InventoryRepositoryMock {
	if mmBuyItem.defaultExpectation != nil {
		mmBuyItem.mock.t.Fatalf("Default expectation is already set for the InventoryRepository.BuyItem method")
	}

	if len(mmBuyItem.expectations) > 0 {
		mmBuyItem.mock.t.Fatalf("Some expectations are already set for the InventoryRepository.BuyItem method")
	}

	mmBuyItem.mock.funcBuyItem = f
	mmBuyItem.mock.funcBuyItemOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// When sets expectation for the InventoryRepository.BuyItem which will trigger the result defined by the following
// Then helper
func (mmBuyItem *mInventoryRepositoryMockBuyItem) When(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying) *InventoryRepositoryMockBuyItemExpectation {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("InventoryRepositoryMock.BuyItem mock is already set by Set")
	}

	expectation := &InventoryRepositoryMockBuyItemExpectation{
		mock:               mmBuyItem.mock,
		params:             &InventoryRepositoryMockBuyItemParams{ctx, tx, buying},
		expectationOrigins: InventoryRepositoryMockBuyItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuyItem.expectations = append(mmBuyItem.expectations, expectation)
	return expectation
}

// Then sets up InventoryRepository.BuyItem return parameters for the expectation previously defined by the When method
func (e *InventoryRepositoryMockBuyItemExpectation) Then(err error) *InventoryRepositoryMock {
	e.results = &InventoryRepositoryMockBuyItemResults{err}
	return e.mock
}

// Times sets number of times InventoryRepository.BuyItem should be invoked
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Times(n uint64) *mInventoryRepositoryMockBuyItem {
	if n == 0 {
		mmBuyItem.mock.t.Fatalf("Times of InventoryRepositoryMock.BuyItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuyItem.expectedInvocations, n)
	mmBuyItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuyItem
}

func (mmBuyItem *mInventoryRepositoryMockBuyItem) invocationsDone() bool {
	if len(mmBuyItem.expectations) == 0 && mmBuyItem.defaultExpectation == nil && mmBuyItem.mock.funcBuyItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuyItem.mock.afterBuyItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuyItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BuyItem implements mm_repository.InventoryRepository
func (mmBuyItem *InventoryRepositoryMock) BuyItem(ctx context.Context, tx pgx.Tx, buying *inventoryModel.Buying) (err error) {
	mm_atomic.AddUint64(&mmBuyItem.beforeBuyItemCounter, 1)
	defer mm_atomic.AddUint64(&mmBuyItem.afterBuyItemCounter, 1)

	mmBuyItem.t.Helper()

	if mmBuyItem.inspectFuncBuyItem != nil {
		mmBuyItem.inspectFuncBuyItem(ctx, tx, buying)
	}

	mm_params := InventoryRepositoryMockBuyItemParams{ctx, tx, buying}

	// Record call args
	mmBuyItem.BuyItemMock.mutex.Lock()
	mmBuyItem.BuyItemMock.callArgs = append(mmBuyItem.BuyItemMock.callArgs, &mm_params)
	mmBuyItem.BuyItemMock.mutex.Unlock()

	for _, e := range mmBuyItem.BuyItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBuyItem.BuyItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuyItem.BuyItemMock.defaultExpectation.Counter, 1)
		mm_want := mmBuyItem.BuyItemMock.defaultExpectation.params
		mm_want_ptrs := mmBuyItem.BuyItemMock.defaultExpectation.paramPtrs

		mm_got := InventoryRepositoryMockBuyItemParams{ctx, tx, buying}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuyItem.t.Errorf("InventoryRepositoryMock.BuyItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmBuyItem.t.Errorf("InventoryRepositoryMock.BuyItem got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.buying != nil && !minimock.Equal(*mm_want_ptrs.buying, mm_got.buying) {
				mmBuyItem.t.Errorf("InventoryRepositoryMock.BuyItem got unexpected parameter buying, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originBuying, *mm_want_ptrs.buying, mm_got.buying, minimock.Diff(*mm_want_ptrs.buying, mm_got.buying))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuyItem.t.Errorf("InventoryRepositoryMock.BuyItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuyItem.BuyItemMock.defaultExpectation.results
		if mm_results == nil {
			mmBuyItem.t.Fatal("No results are set for the InventoryRepositoryMock.BuyItem")
		}
		return (*mm_results).err
	}
	if mmBuyItem.funcBuyItem != nil {
		return mmBuyItem.funcBuyItem(ctx, tx, buying)
	}
	mmBuyItem.t.Fatalf("Unexpected call to InventoryRepositoryMock.BuyItem. %v %v %v", ctx, tx, buying)
	return
}

// BuyItemAfterCounter returns a count of finished InventoryRepositoryMock.BuyItem invocations
func (mmBuyItem *InventoryRepositoryMock) BuyItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.afterBuyItemCounter)
}

// BuyItemBeforeCounter returns a count of InventoryRepositoryMock.BuyItem invocations
func (mmBuyItem *InventoryRepositoryMock) BuyItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.beforeBuyItemCounter)
}

// Calls returns a list of arguments used in each call to InventoryRepositoryMock.BuyItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuyItem *mInventoryRepositoryMockBuyItem) Calls() []*InventoryRepositoryMockBuyItemParams {
	mmBuyItem.mutex.RLock()

	argCopy := make([]*InventoryRepositoryMockBuyItemParams, len(mmBuyItem.callArgs))
	copy(argCopy, mmBuyItem.callArgs)

	mmBuyItem.mutex.RUnlock()

	return argCopy
}

// MinimockBuyItemDone returns true if the count of the BuyItem invocations corresponds
// the number of defined expectations
func (m *InventoryRepositoryMock) MinimockBuyItemDone() bool {
	if m.BuyItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyItemMock.invocationsDone()
}

// MinimockBuyItemInspect logs each unmet expectation
func (m *InventoryRepositoryMock) MinimockBuyItemInspect() {
	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InventoryRepositoryMock.BuyItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyItemCounter := mm_atomic.LoadUint64(&m.afterBuyItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyItemMock.defaultExpectation != nil && afterBuyItemCounter < 1 {
		if m.BuyItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InventoryRepositoryMock.BuyItem at\n%s", m.BuyItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InventoryRepositoryMock.BuyItem at\n%s with params: %#v", m.BuyItemMock.defaultExpectation.expectationOrigins.origin, *m.BuyItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuyItem != nil && afterBuyItemCounter < 1 {
		m.t.Errorf("Expected call to InventoryRepositoryMock.BuyItem at\n%s", m.funcBuyItemOrigin)
	}

	if !m.BuyItemMock.invocationsDone() && afterBuyItemCounter > 0 {
		m.t.Errorf("Expected %d calls to InventoryRepositoryMock.BuyItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyItemMock.expectedInvocations), m.BuyItemMock.expectedInvocationsOrigin, afterBuyItemCounter)
	}
}

type mInventoryRepositoryMockGetInventoryByID struct {
	optional           bool
	mock               *InventoryRepositoryMock
	defaultExpectation *InventoryRepositoryMockGetInventoryByIDExpectation
	expectations       []*InventoryRepositoryMockGetInventoryByIDExpectation

	callArgs []*InventoryRepositoryMockGetInventoryByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// InventoryRepositoryMockGetInventoryByIDExpectation specifies expectation struct of the InventoryRepository.GetInventoryByID
type InventoryRepositoryMockGetInventoryByIDExpectation struct {
	mock               *InventoryRepositoryMock
	params             *InventoryRepositoryMockGetInventoryByIDParams
	paramPtrs          *InventoryRepositoryMockGetInventoryByIDParamPtrs
	expectationOrigins InventoryRepositoryMockGetInventoryByIDExpectationOrigins
	results            *InventoryRepositoryMockGetInventoryByIDResults
	returnOrigin       string
	Counter            uint64
}

// InventoryRepositoryMockGetInventoryByIDParams contains parameters of the InventoryRepository.GetInventoryByID
type InventoryRepositoryMockGetInventoryByIDParams struct {
	ctx     context.Context
	tx      pgx.Tx
	ownerID int64
}

// InventoryRepositoryMockGetInventoryByIDParamPtrs contains pointers to parameters of the InventoryRepository.GetInventoryByID
type InventoryRepositoryMockGetInventoryByIDParamPtrs struct {
	ctx     *context.Context
	tx      *pgx.Tx
	ownerID *int64
}

// InventoryRepositoryMockGetInventoryByIDResults contains results of the InventoryRepository.GetInventoryByID
type InventoryRepositoryMockGetInventoryByIDResults struct {
	i1  model.Inventory
	err error
}

// InventoryRepositoryMockGetInventoryByIDOrigins contains origins of expectations of the InventoryRepository.GetInventoryByID
type InventoryRepositoryMockGetInventoryByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originTx      string
	originOwnerID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Optional() *mInventoryRepositoryMockGetInventoryByID {
	mmGetInventoryByID.optional = true
	return mmGetInventoryByID
}

// Expect sets up expected params for InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Expect(ctx context.Context, tx pgx.Tx, ownerID int64) *mInventoryRepositoryMockGetInventoryByID {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	if mmGetInventoryByID.defaultExpectation == nil {
		mmGetInventoryByID.defaultExpectation = &InventoryRepositoryMockGetInventoryByIDExpectation{}
	}

	if mmGetInventoryByID.defaultExpectation.paramPtrs != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by ExpectParams functions")
	}

	mmGetInventoryByID.defaultExpectation.params = &InventoryRepositoryMockGetInventoryByIDParams{ctx, tx, ownerID}
	mmGetInventoryByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInventoryByID.expectations {
		if minimock.Equal(e.params, mmGetInventoryByID.defaultExpectation.params) {
			mmGetInventoryByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInventoryByID.defaultExpectation.params)
		}
	}

	return mmGetInventoryByID
}

// ExpectCtxParam1 sets up expected param ctx for InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) ExpectCtxParam1(ctx context.Context) *mInventoryRepositoryMockGetInventoryByID {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	if mmGetInventoryByID.defaultExpectation == nil {
		mmGetInventoryByID.defaultExpectation = &InventoryRepositoryMockGetInventoryByIDExpectation{}
	}

	if mmGetInventoryByID.defaultExpectation.params != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Expect")
	}

	if mmGetInventoryByID.defaultExpectation.paramPtrs == nil {
		mmGetInventoryByID.defaultExpectation.paramPtrs = &InventoryRepositoryMockGetInventoryByIDParamPtrs{}
	}
	mmGetInventoryByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInventoryByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInventoryByID
}

// ExpectTxParam2 sets up expected param tx for InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) ExpectTxParam2(tx pgx.Tx) *mInventoryRepositoryMockGetInventoryByID {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	if mmGetInventoryByID.defaultExpectation == nil {
		mmGetInventoryByID.defaultExpectation = &InventoryRepositoryMockGetInventoryByIDExpectation{}
	}

	if mmGetInventoryByID.defaultExpectation.params != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Expect")
	}

	if mmGetInventoryByID.defaultExpectation.paramPtrs == nil {
		mmGetInventoryByID.defaultExpectation.paramPtrs = &InventoryRepositoryMockGetInventoryByIDParamPtrs{}
	}
	mmGetInventoryByID.defaultExpectation.paramPtrs.tx = &tx
	mmGetInventoryByID.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmGetInventoryByID
}

// ExpectOwnerIDParam3 sets up expected param ownerID for InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) ExpectOwnerIDParam3(ownerID int64) *mInventoryRepositoryMockGetInventoryByID {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	if mmGetInventoryByID.defaultExpectation == nil {
		mmGetInventoryByID.defaultExpectation = &InventoryRepositoryMockGetInventoryByIDExpectation{}
	}

	if mmGetInventoryByID.defaultExpectation.params != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Expect")
	}

	if mmGetInventoryByID.defaultExpectation.paramPtrs == nil {
		mmGetInventoryByID.defaultExpectation.paramPtrs = &InventoryRepositoryMockGetInventoryByIDParamPtrs{}
	}
	mmGetInventoryByID.defaultExpectation.paramPtrs.ownerID = &ownerID
	mmGetInventoryByID.defaultExpectation.expectationOrigins.originOwnerID = minimock.CallerInfo(1)

	return mmGetInventoryByID
}

// Inspect accepts an inspector function that has same arguments as the InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Inspect(f func(ctx context.Context, tx pgx.Tx, ownerID int64)) *mInventoryRepositoryMockGetInventoryByID {
	if mmGetInventoryByID.mock.inspectFuncGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("Inspect function is already set for InventoryRepositoryMock.GetInventoryByID")
	}

	mmGetInventoryByID.mock.inspectFuncGetInventoryByID = f

	return mmGetInventoryByID
}

// Return sets up results that will be returned by InventoryRepository.GetInventoryByID
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Return(i1 model.Inventory, err error) *InventoryRepositoryMock {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	if mmGetInventoryByID.defaultExpectation == nil {
		mmGetInventoryByID.defaultExpectation = &InventoryRepositoryMockGetInventoryByIDExpectation{mock: mmGetInventoryByID.mock}
	}
	mmGetInventoryByID.defaultExpectation.results = &InventoryRepositoryMockGetInventoryByIDResults{i1, err}
	mmGetInventoryByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInventoryByID.mock
}

// Set uses given function f to mock the InventoryRepository.GetInventoryByID method
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Set(f func(ctx context.Context, tx pgx.Tx, ownerID int64) (i1 model.Inventory, err error)) *InventoryRepositoryMock {
	if mmGetInventoryByID.defaultExpectation != nil {
		mmGetInventoryByID.mock.t.Fatalf("Default expectation is already set for the InventoryRepository.GetInventoryByID method")
	}

	if len(mmGetInventoryByID.expectations) > 0 {
		mmGetInventoryByID.mock.t.Fatalf("Some expectations are already set for the InventoryRepository.GetInventoryByID method")
	}

	mmGetInventoryByID.mock.funcGetInventoryByID = f
	mmGetInventoryByID.mock.funcGetInventoryByIDOrigin = minimock.CallerInfo(1)
	return mmGetInventoryByID.mock
}

// When sets expectation for the InventoryRepository.GetInventoryByID which will trigger the result defined by the following
// Then helper
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) When(ctx context.Context, tx pgx.Tx, ownerID int64) *InventoryRepositoryMockGetInventoryByIDExpectation {
	if mmGetInventoryByID.mock.funcGetInventoryByID != nil {
		mmGetInventoryByID.mock.t.Fatalf("InventoryRepositoryMock.GetInventoryByID mock is already set by Set")
	}

	expectation := &InventoryRepositoryMockGetInventoryByIDExpectation{
		mock:               mmGetInventoryByID.mock,
		params:             &InventoryRepositoryMockGetInventoryByIDParams{ctx, tx, ownerID},
		expectationOrigins: InventoryRepositoryMockGetInventoryByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInventoryByID.expectations = append(mmGetInventoryByID.expectations, expectation)
	return expectation
}

// Then sets up InventoryRepository.GetInventoryByID return parameters for the expectation previously defined by the When method
func (e *InventoryRepositoryMockGetInventoryByIDExpectation) Then(i1 model.Inventory, err error) *InventoryRepositoryMock {
	e.results = &InventoryRepositoryMockGetInventoryByIDResults{i1, err}
	return e.mock
}

// Times sets number of times InventoryRepository.GetInventoryByID should be invoked
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Times(n uint64) *mInventoryRepositoryMockGetInventoryByID {
	if n == 0 {
		mmGetInventoryByID.mock.t.Fatalf("Times of InventoryRepositoryMock.GetInventoryByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInventoryByID.expectedInvocations, n)
	mmGetInventoryByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInventoryByID
}

func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) invocationsDone() bool {
	if len(mmGetInventoryByID.expectations) == 0 && mmGetInventoryByID.defaultExpectation == nil && mmGetInventoryByID.mock.funcGetInventoryByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInventoryByID.mock.afterGetInventoryByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInventoryByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInventoryByID implements mm_repository.InventoryRepository
func (mmGetInventoryByID *InventoryRepositoryMock) GetInventoryByID(ctx context.Context, tx pgx.Tx, ownerID int64) (i1 model.Inventory, err error) {
	mm_atomic.AddUint64(&mmGetInventoryByID.beforeGetInventoryByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInventoryByID.afterGetInventoryByIDCounter, 1)

	mmGetInventoryByID.t.Helper()

	if mmGetInventoryByID.inspectFuncGetInventoryByID != nil {
		mmGetInventoryByID.inspectFuncGetInventoryByID(ctx, tx, ownerID)
	}

	mm_params := InventoryRepositoryMockGetInventoryByIDParams{ctx, tx, ownerID}

	// Record call args
	mmGetInventoryByID.GetInventoryByIDMock.mutex.Lock()
	mmGetInventoryByID.GetInventoryByIDMock.callArgs = append(mmGetInventoryByID.GetInventoryByIDMock.callArgs, &mm_params)
	mmGetInventoryByID.GetInventoryByIDMock.mutex.Unlock()

	for _, e := range mmGetInventoryByID.GetInventoryByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.paramPtrs

		mm_got := InventoryRepositoryMockGetInventoryByIDParams{ctx, tx, ownerID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInventoryByID.t.Errorf("InventoryRepositoryMock.GetInventoryByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmGetInventoryByID.t.Errorf("InventoryRepositoryMock.GetInventoryByID got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.ownerID != nil && !minimock.Equal(*mm_want_ptrs.ownerID, mm_got.ownerID) {
				mmGetInventoryByID.t.Errorf("InventoryRepositoryMock.GetInventoryByID got unexpected parameter ownerID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.expectationOrigins.originOwnerID, *mm_want_ptrs.ownerID, mm_got.ownerID, minimock.Diff(*mm_want_ptrs.ownerID, mm_got.ownerID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInventoryByID.t.Errorf("InventoryRepositoryMock.GetInventoryByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInventoryByID.GetInventoryByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInventoryByID.t.Fatal("No results are set for the InventoryRepositoryMock.GetInventoryByID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetInventoryByID.funcGetInventoryByID != nil {
		return mmGetInventoryByID.funcGetInventoryByID(ctx, tx, ownerID)
	}
	mmGetInventoryByID.t.Fatalf("Unexpected call to InventoryRepositoryMock.GetInventoryByID. %v %v %v", ctx, tx, ownerID)
	return
}

// GetInventoryByIDAfterCounter returns a count of finished InventoryRepositoryMock.GetInventoryByID invocations
func (mmGetInventoryByID *InventoryRepositoryMock) GetInventoryByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInventoryByID.afterGetInventoryByIDCounter)
}

// GetInventoryByIDBeforeCounter returns a count of InventoryRepositoryMock.GetInventoryByID invocations
func (mmGetInventoryByID *InventoryRepositoryMock) GetInventoryByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInventoryByID.beforeGetInventoryByIDCounter)
}

// Calls returns a list of arguments used in each call to InventoryRepositoryMock.GetInventoryByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInventoryByID *mInventoryRepositoryMockGetInventoryByID) Calls() []*InventoryRepositoryMockGetInventoryByIDParams {
	mmGetInventoryByID.mutex.RLock()

	argCopy := make([]*InventoryRepositoryMockGetInventoryByIDParams, len(mmGetInventoryByID.callArgs))
	copy(argCopy, mmGetInventoryByID.callArgs)

	mmGetInventoryByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetInventoryByIDDone returns true if the count of the GetInventoryByID invocations corresponds
// the number of defined expectations
func (m *InventoryRepositoryMock) MinimockGetInventoryByIDDone() bool {
	if m.GetInventoryByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInventoryByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInventoryByIDMock.invocationsDone()
}

// MinimockGetInventoryByIDInspect logs each unmet expectation
func (m *InventoryRepositoryMock) MinimockGetInventoryByIDInspect() {
	for _, e := range m.GetInventoryByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InventoryRepositoryMock.GetInventoryByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInventoryByIDCounter := mm_atomic.LoadUint64(&m.afterGetInventoryByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInventoryByIDMock.defaultExpectation != nil && afterGetInventoryByIDCounter < 1 {
		if m.GetInventoryByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to InventoryRepositoryMock.GetInventoryByID at\n%s", m.GetInventoryByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to InventoryRepositoryMock.GetInventoryByID at\n%s with params: %#v", m.GetInventoryByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetInventoryByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInventoryByID != nil && afterGetInventoryByIDCounter < 1 {
		m.t.Errorf("Expected call to InventoryRepositoryMock.GetInventoryByID at\n%s", m.funcGetInventoryByIDOrigin)
	}

	if !m.GetInventoryByIDMock.invocationsDone() && afterGetInventoryByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to InventoryRepositoryMock.GetInventoryByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInventoryByIDMock.expectedInvocations), m.GetInventoryByIDMock.expectedInvocationsOrigin, afterGetInventoryByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InventoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBuyItemInspect()

			m.MinimockGetInventoryByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InventoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InventoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuyItemDone() &&
		m.MinimockGetInventoryByIDDone()
}
